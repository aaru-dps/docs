<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Atari ST FD Software Information</title>
<meta name="description" content="Atari ST Diskette Information" />
<meta name="AUTHOR" content="Jean Louis-Guerin" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="../../_info-coach/infoCoach.css" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="../_atari/atari.css">
<script src="/SpryAssets/SpryMenuBar.js" type="text/javascript"></script>
<link href="/SpryAssets/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css" />

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7991018-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


</head>
<body class="oneCol">
<div id="container">
  <div id="header">
    <h1> Atari  ST FD Software</h1>
    <p>Last updated 
      <!-- #BeginDate format:Am1a -->August 4, 2012 12:00 PM<!-- #EndDate --> 
    </p>
    <div id="siteNavBar">
<ul>
<li><a href="/index.php">Home</a></li>
<li><a href="/services/index.php">Services</a></li>
<li><a href="/pc/index.php">Pc</a></li>
<li><a href="/atari/index.php" id="current">Atari</a></li>
<li><a href="/research/index.php">Research</a></li>
</ul>
</div>
<ul id="secNavBar" class="MenuBarHorizontal">
<li><a class="MenuBarItemSubmenu" href="/atari/documents/index.php">Documents</a>
<ul>
<li><a href="/atari/documents/myFAQ.php">MyFAQ</a></li>
<li><a href="/atari/documents/myDoc.php">MyDoc</a></li>
<li><a href="/atari/documents/general.php">General</a></li>
<li><a href="/atari/documents/datasheets.php">Datasheets</a></li>
</ul></li>
<li><a class="MenuBarItemSubmenu" href="/atari/hardware/index.php">Hardware</a>
<ul>
<li><a href="/atari/hardware/FD-Hard.php">FD-Hard</a></li>
<li><a href="/atari/hardware/HD-Hard.php">HD-Hard</a></li>
<li><a class="MenuBarItemSubmenu" href="/atari/hardware/devices/index.php">Devices</a>
<ul>
<li><a href="/atari/hardware/devices/supercard.php">Supercard</a></li>
<li><a href="/atari/hardware/devices/kryoflux.php">Kryoflux</a></li>
<li><a href="/atari/hardware/devices/DC.php">DC</a></li>
</ul></li>
<li><a href="/atari/hardware/STE-HW.php">STE-HW</a></li>
<li><a href="/atari/hardware/interfaces.php">Interfaces</a></li>
<li><a href="/atari/hardware/video.php">Video</a></li>
<li><a href="/atari/hardware/memory.php">Memory</a></li>
<li><a href="/atari/hardware/disasembly.php">Disasembly</a></li>
</ul></li>
<li><a class="MenuBarItemSubmenu" href="/atari/software/index.php" id="current">Software</a>
<ul>
<li><a href="/atari/software/FD-Soft.php">FD-Soft</a></li>
<li><a href="/atari/software/HD-Soft.php">HD-Soft</a></li>
<li><a class="MenuBarItemSubmenu" href="/atari/software/system/index.php">System</a>
<ul>
<li><a href="/atari/software/system/GEM.php">GEM</a></li>
<li><a href="/atari/software/system/BIG.php">BIG</a></li>
<li><a href="/atari/software/system/TOS.php">TOS</a></li>
</ul></li>
<li><a class="MenuBarItemSubmenu" href="/atari/software/projects/index.php">Projects</a>
<ul>
<li><a href="/atari/software/projects/steem.php">Steem</a></li>
<li><a href="/atari/software/projects/ipf.php">Ipf</a></li>
<li><a href="/atari/software/projects/FD-Lib.php">FD-Lib</a></li>
<li><a href="/atari/software/projects/kryoflux.php">Kryoflux</a></li>
<li><a href="/atari/software/projects/KFAnalysis.php">KFAnalysis</a></li>
</ul></li>
<li><a href="/atari/software/languages.php">Languages</a></li>
<li><a href="/atari/software/preservation.php">Preservation</a></li>
<li><a href="/atari/software/FD-Images.php">FD-Images</a></li>
</ul></li>
<li><a href="/atari/links.php">Links</a></li>
</ul>
<script type="text/javascript">
var navBar1 = new Spry.Widget.MenuBar("secNavBar", {imgDown:"/SpryAssets/SpryMenuBarDownHover.gif", imgRight:"/SpryAssets/SpryMenuBarRightHover.gif"});
</script>
  </div>
  <!-- end #header -->
  <div id="sbFloatRight">
    <h1>Table of Content </h1>
    <ul>
      <li><a href="#fd_soft_llf">Atari Low Level Formatting</a>
        <ul>
          <li><a href="#fd_soft_dd_formats">Atari / PC / ISO DD Formats</a></li>
          <li><a href="#fd_soft_atari_dd_format">Atari Standard Double Density Format</a></li>
          <li><a href="#fd_soft_standard_512B_formats">Standard 9-10-11 * 512 Bytes Sect.   Format</a></li>
          <li><a href="#fd_soft_standard_format_bytes_other">Std 128-256-512-1024 Bytes/Sect. Format</a></li>
        </ul>
      </li>
      <blockquote>
        <p><a href="#overall_desc">Overall Track/Sector Description</a></p>
      </blockquote>
      <ul>
        <li><a href="#tdesc">Track Description</a></li>
        <li><a href="#sect_id">Sector ID Description</a></li>
        <li><a href="#sect_data">Sector DATA Description</a></li>
        <li><a href="#tsplice">Track Write Splice</a></li>
        <li><a href="#ssplice">Sector Write Splice</a></li>
      </ul>
      <li></li>
      <li><a href="#atari_fd_layout">Atari High-Level Formatting</a>
      </li>
      <ul>
        <li><a href="#fd_soft_getting_fd_ready">Getting a Floppy Disk Ready</a></li>
        <li><a href="#fd_soft_bs">The Boot Sector</a></li>
        <li><a href="#fd_soft_directory">Directory Structure</a></li>
        <li><a href="#fd_soft_fat">FAT Structure</a></li>
      </ul>
      <li></li>
      <li><a href="#fd_soft_images">Floppy Disk Images</a>
        <ul>
          <li><a href="#fd_soft_image_formats">Disk Image Formats</a></li>
          <li><a href="#format_emul">Format Supported by Emulators</a></li>
          <li><a href="#fd_soft_images_from_floppies">Making disk images from FDs</a></li>
          <li><a href="#fd_soft_floppies_from_images">Making FDs from disk images</a></li>
          <li><a href="#fd_soft_image_utilities">Disk Image Utilities</a></li>
        </ul>
      </li>
      <li></li>
      <li>  </li>
    </ul>
</div>
  <div id="mainContent">
    <p>This page contains information about ST Floppy disks from a software &quot;point of view&quot;: This includes  information on FD layouts, Low and High level FD format, 
    FD images,  etc...</p>
    <p>There is another page on the <a href="/atari/hardware/FD-Hard.php">Hardware side of the Atari ST Floppy Disks</a> containing information on the Floppy Disk Media (down to 
    the flux level), the FD Drives, the FD controller, etc ...</p>
    <p>This information should  be specially usefull  for <a href="/atari/software/preservation.php">duplication (backup)  or preservation (images)</a> of Atari ST diskettes (protected or not).</p>
    <p>&nbsp;</p>
<h1><a name="fd_soft_llf">Atari Low Level Formatt</a>ing</h1>
    <p>The first step in preparing a diskette involves the creation of the actual structures on the surface of the media that are used to hold the data. 
      This means recording the tracks and marking the start of each sector on each track. This is called <i>low-level formatting</i>, 
      and sometimes it is called &quot;true formatting&quot; since it is actually recording the format that will be used to store information on the disk. 
      Once the floppy disk has been low-level formatted, the locations of the tracks and sectors on the 
    disk are fixed in place.</p>
<ul>
  <li><a href="#fd_soft_dd_formats">Atari / PC / ISO DD Formats</a></li>
  <li><a href="#fd_soft_atari_dd_format">Atari Standard Double Density Format</a></li>
  <li><a href="#fd_soft_standard_512B_formats">Standard 9-10-11 Sectors of 512 Bytes Format</a></li>
  <li><a href="#fd_soft_standard_format_bytes_other">Standards 128-256-512-1024 Bytes / Sector Format</a></li>
</ul><a href="FD-Soft.php" class="btt"> Back to the top</a>
<h2><a name="fd_soft_dd_formats" id="fd_soft_dd_formats"></a>Atari / PC / ISO Formats    </h2>
<p>The Atari ST uses the Western Digital <a href="/atari/hardware/FD-Hard.php#WD1772">WD1772 Floppy Disc Controller</a> (FDC) to 
      access the 3 1/2 inch (or to be more precise 90mm) floppy disks. Western Digital was recommending to use the <b>IBM 3740 Format </b>for Single Density diskette and to use the 
      <a href="/atari/software/fd-soft/ibm-fmt.gif">IBM System 34 Format</a> for Double Density diskette. Actually the default Atari Format used by the TOS is 
      slightly different (nearer to the <a href="/atari/software/fd-soft/iso-fmt.gif">ISO Double Density Format</a>) as it does not have an <b>IAM</b> byte (and associated GAP), 
      before the first <b>IDAM</b> sector of the track (see diagram below). <br>
      However the WD1772 ( and therefore the Atari) is capable to read both format without problem but the reverse is usually not true (i.e. floppies <i>formatted</i> on 
      early Atari machines can't be read on PCs but floppies created on PC can be read on Atari).</p>
    <p><img src="/atari/software/fd-soft/ibm-dd-fmt.gif" border="0" class="imageCenter">
      IBM <b>System 34</b> Double Density Format (this is the format produced on a DOS machine formatting in 720K)</p>
    <p>&nbsp;</p>
    <p><img src="/atari/software/fd-soft/iso-dd-fmt.gif" width="950" height="54" border="0" class="imageCenter"> ISO Double Density Format.</p>
<a href="FD-Soft.php" class="btt"> Back to the top</a>
    <h2><a name="fd_soft_atari_dd_format">Atari Standard Double Density Format</a></h2>
    <p>Below is a detail description of the &quot;<b>Standard Atari Double Density Format</b>&quot; as created by the early TOS.<br>
      Note: There is no standard GAPS<strong> naming convention</strong> and it is not clear on how they must be decomposed. This document uses a GAP naming/numbering scheme which is a combination of the IBM and ISO standards with  more 
      details for the description of the GAP between the ID record and the DATA record. Usually only one gap is used to describe the content between these two records but here we decompose it into a post 
      ID gap (Gap 3a) and a pre-data gap (Gap 3b) as this allow a more detail description. Of course they can be easily combined into one Gap 3 which is more conventional. Not show 
      in the diagram below when the floppy is formatted with an IAM (index address mark) the Gap1 is further decomposed into two gaps: A post index gap (Gap1a) and a post 
      IAM gap (Gap1b).</p>
    <p>&nbsp;</p>
<img src="/atari/software/fd-soft/atari-dd-fmt.gif" width="985" height="181" border="0" class="imageCenter">
	<p>&nbsp;</p>
	<p>The tables below indicates the standard values of the different gaps in a &quot;standard&quot; Atari diskette with 9 sectors of 512 user data bytes. It also 
	  indicates the minimum acceptable values of these gaps, as specified in the WD1772 datasheet, when formatting non standard diskettes.</p>
	<p>&nbsp;</p>
    <table border="1" align="center" cellspacing="0" bordercolor="#FFFF00">
      <tr>
        <td width="156"><b>Name</b></td>
        <td width="250"><b>Standard Values (9 sectors)</b></td>
        <td width="250"><b>Minimum Values (Datasheet)</b></td>
      </tr>
      <tr>
        <td width="156">Gap 1 Post Index</td>
        <td width="250">60 x $4E</td>
        <td width="250">32 x $4E</td>
      </tr>
      <tr>
        <td width="156">Gap 2 Pre ID</td>
        <td width="250">12 x $00 + 3 x $A1</td>
        <td width="250">8 x 00 + 3 x $A1</td>
      </tr>
      <tr>
        <td width="156">Gap 3a Post ID</td>
        <td width="250">22 x $4E</td>
        <td width="250">22 x $4E</td>
      </tr>
      <tr>
        <td width="156">Gap 3b Pre Data</td>
        <td width="250">12 x $00 + 3 x $A1</td>
        <td width="250">12 x $00 + 3 x $A1</td>
      </tr>
      <tr>
        <td width="156">Gap 4 Post Data</td>
        <td width="250">40 x $4E</td>
        <td width="250">24 x $4E</td>
      </tr>
      <tr>
        <td width="156">Gap 5 Pre Index</td>
        <td width="250">~ 664 x $4E</td>
        <td width="250">16 x $4E</td>
      </tr>
    </table>
    <p>Standard Record Gap Value (Gap 2 + Gap 3a + Gap 3b + Gap 4) = 92 Bytes / Record<br>
      Minimum Record Gap Value (Gap 2 + Gap 3a + Gap 3b + Gap 4) = 72 Bytes / Record<br>
      Standard Record Length (Record Gap + ID + DATA) = 92 + 7 + 515 = 614 bytes<br>
      Minimum Record Length (Record GAP + ID + DATA) = 72 + 7 + 515 = 594</p><a href="FD-Soft.php" class="btt"> Back to the top</a>
    <h2><a name="fd_soft_standard_512B_formats">Standard 9-10-11 Sectors of 512 Bytes Format</a></h2>
    <p>Note that the 3 1/2 FD are spinning at 300 RPM which implies a 200 ms total track time. As the MFM cells have a length of 4 
    µsec this gives a total of 50000 cells and therefore about <b> 6250</b> bytes per track.</p>
    <p>The table below indicates possible (i.e. classical) values of the gaps for 
      tracks with 9, 10, and 11 sectors.</p>
    <table border="1" align="center" cellpadding="2" cellspacing="0" bordercolor="#FFFF00">
      <tr>
        <td width="200"><b>Name</b></td>
        <td width="200"><b>9 Sectors: # bytes</b></td>
        <td width="200"><b>10 Sectors: # bytes</b></td>
        <td width="200"><b>11 Sectors: # bytes</b></td>
      </tr>
      <tr>
        <td width="200">Gap 1 Post Index</td>
        <td width="200" align="center">60</td>
        <td width="200" align="center">60</td>
        <td width="200" align="center"><span style="background-color: #808000">10</span></td>
      </tr>
      <tr>
        <td width="200">Gap 2 Pre ID</td>
        <td width="200" align="center">12+3</td>
        <td width="200" align="center">12+3</td>
        <td width="200" align="center"><span style="background-color: #808000">3+3</span></td>
      </tr>
      <tr>
        <td width="200">Gap 3a Post ID</td>
        <td width="200" align="center">22</td>
        <td width="200" align="center">22</td>
        <td width="200" align="center">22</td>
      </tr>
      <tr>
        <td width="200">Gap 3b Pre Data</td>
        <td width="200" align="center">12+3</td>
        <td width="200" align="center">12+3</td>
        <td width="200" align="center">12+3</td>
      </tr>
      <tr>
        <td width="200">Gap 4 Post Data</td>
        <td width="200" align="center">40</td>
        <td width="200" align="center">40</td>
        <td width="200" align="center"><span style="background-color: #808000">1</span></td>
      </tr>
      <tr>
        <td width="200">Gap 2-4</td>
        <td width="200" align="center">92</td>
        <td width="200" align="center">92</td>
        <td width="200" align="center">44</td>
      </tr>
      <tr>
        <td width="200">Record Length</td>
        <td width="200" align="center">614</td>
        <td width="200" align="center">614</td>
        <td width="200" align="center">566</td>
      </tr>
      <tr>
        <td width="200">Gap 5 Pre Index</td>
        <td width="200" align="center">664</td>
        <td width="200" align="center">50</td>
        <td width="200" align="center">20</td>
      </tr>
      <tr>
        <td width="200">Total Track</td>
        <td width="200" align="center">6250</td>
        <td width="200" align="center">6250</td>
        <td width="200" align="center">6250</td>
      </tr>
    </table>
    <p>Respecting all the minimum value on an 11 sectors / track gives a length of: L = Min Gap 1 + (11 x Min Record Length) + Min Gap 5 = 32 + 6534 + 16 = 6582 (which 
      is 332 bytes <strong>above</strong> max track length). Therefore we need to decrease by about 32 bytes per sector in order to be 
      able to write such a track. For example the last column of the table above shows values 
      as used by <u>Superformat v2.2</u> program for 11 sectors/track (values analyzed with a Discovery Cartridge). 
    As you can see the track is formatted with a Gap 2 <b>reduced to 6</b> and Gap 4 <b>reduced to 1 !</b> </p>
    <p>These values do not 
      respect the minimum specified by the WD1772 datasheet but they make sense as it is <b>mandatory</b> to let enough time to the FDC between the ID block and the 
      corresponding DATA block which implies that <b>Gap 3a &amp; 3b should not be shorten</b>.&nbsp; The reduction of gap 4 plus gap 2 
      to <u>only 7 bytes</u> between a DATA block and the next ID block does not let enough time to the FDC to read the next sector on the fly but 
      this is acceptable as this sector can be read on the next rotation of the FD. This has an obviously <u>impact on performance</u> that can be minimized by using 
      sectors interleaving (<a href="#Interleaving">explain below</a>). But it is <b>somewhat dangerous </b>to have 
      such a short gap between the data and the next ID because the writing of a data block need to be perfectly calibrated or it will collide with 
      the next ID block. This is why such a track is actually reported as <b>&quot;read only&quot;</b> in 
      the DC documentation and is sometimes used as a protection mechanism.<br>
      Of course you have more chance to successfully write 11 sectors on the first track (the outer one) than on the last track (the inner one) as the bit 
      density gets higher in the later case. It is also important to have a floppy drive that have a stable and minimum rotation speed deviation (i.e. 
    RPM should not be more than 1% above 300).</p>
    <a href="FD-Soft.php" class="btt"> Back to the top</a>
    <h2><a name="fd_soft_standard_format_bytes_other">Standard 128-256-512-1024 Bytes / Sector Format</a></h2>
    <p>The table below indicates some &quot;classical&quot; gaps values for 
      tracks with sectors of size of 128, 256, 512, and 1024.</p>
    <table border="1" align="center" cellspacing="0" bordercolor="#FFFF00">
      <tr>
        <td width="200" align="center"><b>Name</b></td>
        <td width="200" align="center"><b>29 sectors of 128 bytes</b></td>
        <td width="200" align="center"><b>18 sectors of 256 bytes</b></td>
        <td width="200" align="center"><b>9 Sectors of 512 bytes</b></td>
        <td width="200" align="center"><b>5 Sectors of 1024 bytes</b></td>
      </tr>
      <tr>
        <td width="200">Gap 1 Post Index</td>
        <td width="200" align="center">40</td>
        <td width="200" align="center">42</td>
        <td width="200" align="center">60</td>
        <td width="200" align="center">60</td>
      </tr>
      <tr>
        <td width="200">Gap 2 Pre ID</td>
        <td width="200" align="center">10+3</td>
        <td width="200" align="center">11+3</td>
        <td width="200" align="center">12+3</td>
        <td width="200" align="center">40+3</td>
      </tr>
      <tr>
        <td width="200">Gap 3a Post ID</td>
        <td width="200" align="center">22</td>
        <td width="200" align="center">22</td>
        <td width="200" align="center">22</td>
        <td width="200" align="center">22</td>
      </tr>
      <tr>
        <td width="200">Gap 3b Pre Data</td>
        <td width="200" align="center">12+3</td>
        <td width="200" align="center">12+3</td>
        <td width="200" align="center">12+3</td>
        <td width="200" align="center">12+3</td>
      </tr>
      <tr>
        <td width="200">Gap 4 Post Data</td>
        <td width="200" align="center">25</td>
        <td width="200" align="center">26</td>
        <td width="200" align="center">40</td>
        <td width="200" align="center">40</td>
      </tr>
      <tr>
        <td width="200">Gap 2-4</td>
        <td width="200" align="center">75</td>
        <td width="200" align="center">77</td>
        <td width="200" align="center">92</td>
        <td width="200" align="center">120</td>
      </tr>
      <tr>
        <td width="200">Record Length</td>
        <td width="200" align="center">213</td>
        <td width="200" align="center">343</td>
        <td width="200" align="center">614</td>
        <td width="200" align="center">1154</td>
      </tr>
      <tr>
        <td width="200">Gap 5</td>
        <td width="200" align="center">73</td>
        <td width="200" align="center">76</td>
        <td width="200" align="center">664</td>
        <td width="200" align="center">480</td>
      </tr>
      <tr>
        <td width="200">Total Track</td>
        <td width="200" align="center">6250</td>
        <td width="200" align="center">6250</td>
        <td width="200" align="center">6250</td>
        <td width="200" align="center">6250</td>
      </tr>
    </table>
    <p><a name="Interleaving"><strong>Interleaving</strong></a>: Normally the sector number is incremented by 1 for each record (i.e. there is no need to 
    interleave with DD like it used to be with older FD) however sectors can written be in any order.</p>
    <p><a href="FD-Soft.php" class="btt"> Back to the top</a>
    </p>
    <h1><a name="overall_desc" id="overall_desc"></a>Overall Track / Sector Description</h1>
    <h2><a name="tdesc" id="tdesc"></a>Track Description</h2>
    <p><img src="/atari/hardware/fd-hard/pictures/track.png" width="1000" height="461" /></p>
    <a href="FD-Soft.php" class="btt"> Back to the top</a>
    <h2><a name="sect_id" id="sect_id"></a>Sector ID Segment</h2>
    <p><img src="/atari/hardware/fd-hard/pictures/id-segment.png" width="1000" height="158" /></p>
    <p>&nbsp;</p>
    <ul>
      <li>ID PREAMBLE 
        <ul>
          <li>PLL SYNCH FIELD<br />
            This is a 12 bytes long field of repetitive clocked data  bits. The preamble normally will be all zeroes of  NRZ data (encoded as 1010. . . in MFM). During the ID preamble, the signal Read  Gate will go active, indicating that the incoming data pattern has to be locked  on to.</li>
          <li>ID SYNCH FIELD
            <br />
            The synch mark byte contains a missing  clock code violation, typically in MFM. The violation is detected by circuitry  to indicate the start of an ID Field or a Data Field. The first decoded byte  that does not contain all 0s after the preamble will be the synch mark. The  first 1 to be received is then used to byte align after the all zeroes  preamble. The DD format have three ID synch mark byte. On  soft sectored drives Synch field precedes the address mark (AM). </li>
        </ul>
      </li>
      <li>ID FIELD      
        <ul>
          <li>ID ADDRESS MARK FIELD<br />
            ID Address Mark (IDAM) is required on soft  sectored drives to indicate the beginning of a sector, because this type of  drive does not have a sector pulse at the start of each sector. </li>
          <li>ID content Field      <br />
            The ID content Field format contains a track number  bytes, a sector number byte, a head number byte. It is  4 bytes long. </li>
          <li>ID CRC FIELD<br />
            CRC (Cyclic Redundancy Checking) code is  appended to the header field. The CRC consists of two bytes of the standard CRC-CCITT  polynomial. The code detects errors in the header field. This appendage is basically  a protection field to make sure that the ID field contains valid information. </li>
        </ul>
      </li>
      <li>ID POSTAMBLE<br />
        This field is used to give the disk  controller time to interpret the data found in the ID field and to act upon it.  It provides slack for write splicing that occurs between the ID and Data  segment. A Write splice occurs when the read/ write head starts writing the  data field. A splice is created each time a sector's data segment is written  to. The slight variations in the rotational speeds cause the first flux change  to occur in different positions for each write operation. It also allows time  in a write disk operation for the read/write circuitry to be switched from read  to write mode. Finally it allows time for the PLL circuit to re-lock on to a  fixed reference clock before it returns to synchronize to the preamble of the  data field. </li>
    </ul>
    <a href="FD-Soft.php" class="btt"> Back to the top</a>
    <h2><a name="sect_data" id="sect_data"></a>Sector DATA Segment</h2>
<p><img src="/atari/hardware/fd-hard/pictures/data-segment.png" width="1000" height="154" /></p>
<p>&nbsp;</p>
<ul>
  <li>Data PREAMBLE FIELD    
    <ul>
      <li>PLL Synch Field
        <br />
        The Data Preamble field is necessary when  reading a sector's data. It ensures that the PLL circuit locks on to the Data  segment data rate. Initially, the ID segment and the data segment of every  sector will be written when formatting the disk, but the Data segment will be  written over later. Due to drive motor speed variations within the tolerance  specified, the ID and Data segments will have slightly different data rates  because they are written at different times. This implies that the PLL must  adjust its frequency and phase in order to lock on to the data rate of the Data  segment before the incoming preamble field has finished. Hence the need for a  second preamble field in the sector. </li>
      <li>DATA SYNCH FIELD
        <br />
        Following the PLL Synch Field will be the Data  synch field similar to the ID synch field.</li>
    </ul>
  </li>
  <li>DATA FIELD 
    <ul>
      <li>Data Address Mark field<br />
        Following the Data Preamble will be the  Data Address Mark for soft sectored drives similar to the ID Address Mark  field. </li>
      <li>Data Content Field<br />
        The Data field is transferred to or from  external memory. It is usually from 128 bytes to 1024 bytes per sector.</li>
      <li>DATA CRC<br />
        A CRC appendage follows the Data field. CRC  generating (when writing to the disk) and checking (when reading from the disk)  are performed on the Data field. Errors may therefore be detected. </li>
    </ul>
  </li>
  <li>DATA POSTAMBLE FIELD <br />
    This has the same  function as the ID Postamble field. It is the final field of the sector. It  allows slack between neighboring sectors. Without this gap, whenever a data  segment is written to a sector, any reduction in drive motor speed at the  instance of writing to the disk would cause an overlap of the data segment and  the succeeding ID segment of the next sector. This field is only written when  formatting the disk. </li>
</ul>
    <p>Note 1: A final gap field is added from the end of the last sector  until the INDEX pulse occurs and this gap is often termed Gap 5. It takes up  the slack from the end of the last sector to the Index pulse.</p>
    <p>Note 2: When writing a sector the write gate is tunrned on at the begining of the DATA preamble (location of the write splicing) and is turned off in the data postamble (one or two bytes after the last CRC).</p>
    <a href="FD-Soft.php" class="btt"> Back to the top</a>
<h2><a name="ssplice" id="ssplice"></a>Sector Write Splice</h2>
    <p>The area at the begining of the DATA preamble provides slack for write splicing that occurs between the ID and Data  segment. A Write splice occurs when the read/ write head starts writing the  data field. A splice is created each time a sector's data segment is written  to. The slight variations in the rotational speeds cause the first flux change  to occur in different positions for each write operation. It also allows time  in a write disk operation for the read/write circuitry to be switched from read  to write mode. </p>
    <a href="FD-Soft.php" class="btt"> Back to the top</a>
    <h2><a name="tsplice" id="tsplice"></a>Track Write Splice    </h2>
    <p>A Track write splice occurs when writing a complete track. When you write a whole track, you start writing bytes at the index mark  for 200ms. The problem is that floppy drives do not run exactly at 300 rpm all the time, so there's pretty much no chance you'll get an exact joining once you've done a complete revolution. So you'll either have some leftover noise just before your starting point, or some overwriting there.</p>
    <a href="FD-Soft.php" class="btt"> Back to the top</a>
<h1><a name="atari_fd_layout">Atari High-Level Formating</a></h1>
    <p><a href="#fd_soft_getting_fd_ready">Getting a Floppy Disk Ready</a></p>
    <p><a href="#fd_soft_bs">The Boot Sector</a></p>
    <p><a href="#fd_soft_directory">Directory Structure</a></p>
    <p><a href="#fd_soft_fat">FAT Structure</a>    </p>
    <h2><a name="fd_soft_getting_fd_ready"> Getting a floppy disk ready</a></h2>
    <p>There are two steps involved in getting a floppy disks ready for usage on an Atari:</p>
    <ul>
      <li>As already  described <a href="#fd_soft_llf">in this section</a> the first step involves the creation of the actual structures on the surface of the media that are used to hold the data ans is called the <em>Low_Level formatting</em>.</li>
      <li>The second  step is called the <i>high-level formatting</i>. This is the process of creating the disk's logical structures such as the 
        <a href="#fd_soft_fat">file allocation table</a> and <a href="#fd_soft_directory">root directory</a>. The high-level format uses the structures created by the 
        low-level format to prepare the disk to hold files using the chosen file system. In order for the TOS to use a diskette it has to know about the number of 
        tracks, the number of sectors per tracks, the size of the sectors and the number of sides. This information is defined in a special sector called the <b>
        <a href="#fd_soft_bs">boot sector</a></b>. Beyond that it is necessary for the TOS&nbsp; to find information (e.g. location of all the sectors 
        belonging to this file, attributes, ...) about any files stored on the diskette as well as global information (e.g. the space still available on the diskette). 
        This information is kept in <b><a href="#fd_soft_directory">directories</a></b> and <b> <a href="#fd_soft_fat">FATs</a></b> structures.</li>
    </ul>
<p><a href="FD-Soft.php" class="btt"> Back to the top</a>
</p>
    <h2><a name="fd_soft_bs">The Boot Sector</a> (BS)</h2>
    <p>The boot sector is always located on track 0, side 0, first sector of the diskette. This sector is tested by the TOS&nbsp; as soon as you change of 
      diskette to find important information about the diskette (e.g. it contains a serial number that identify the diskette). Some parameters are loaded from this sector to 
      be used by the BIOS and are stored in a structure called the BPB (Bios Parameter Block). Eventually the boot sector also contain a bootstrap routine (the loader) that 
      allow to start a relocatable program a boot time (usually a TOS image).</p>
    <p>The structure of the boot sector is described below (<span style="background-color: #808080">the grayed areas are stored in the BPB</span>). Note that the Atari 
        boot sector is similar with the boot sector used by IBM PC and therefore 16 bits words are stored using the low/high bytes <font color="#00FF00">Intel</font> 
      format&nbsp; (e.g. a BPS = $00 $02 indicates a $200 bytes per sector).</p>
<table border="1" cellspacing="0" bordercolor="#FFFF00" id="table43">
      <tr>
        <th align="left" width="120" style="border-color: #FFFF00">Name</th>
        <th width="70" style="border-color: #FFFF00"> <b>Offset</b> </th>
        <th align="left" width="70" style="border-color: #FFFF00">Bytes</th>
        <th align="left" width="800" style="border-color: #FFFF00"><b>Contents</b></th>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00"><b>BRA</b></th>
        <td width="70" align="center" valign="top"> $00 </td>
        <td align="left" width="70" valign="top">2</td>
        <td align="left" width="800" valign="top">This <b>word</b> contains a 
          680x0 BRA.S instruction to the bootstrap code in this sector if the disk is 
          executable, otherwise it is unused. </td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00"><b>OEM</b></th>
        <td width="70" align="left" valign="top">$02 </td>
        <td align="left" width="70" valign="top">6</td>
        <td align="left" width="800" valign="top">These six bytes are reserved 
          for use as any necessary filler information. The disk-based <b>TOS</b> loader program places the string 'Loader' here. </td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00"><b>SERIAL</b></th>
        <td width="70" align="left" valign="top">$08 </td>
        <td align="left" width="70" valign="top">4</td>
        <td align="left" width="800" valign="top">The low 24-bits of this <b>long</b> represent a unique disk serial number. </td>
      </tr>
      <tr>
        <th width="120" align="left" bgcolor="#808080" valign="top" style="border-color: #FFFF00"><b>BPS</b></th>
        <td width="70" align="left" bgcolor="#808080" valign="top">$0B </td>
        <td align="left" bgcolor="#808080" width="70" valign="top"> 2</td>
        <td align="left" bgcolor="#808080" width="800" valign="top">This is an 
          Intel format <b>word</b> (low byte first) which indicates the number of 
          bytes per sector on the disk (usually 512).</td>
      </tr>
      <tr>
        <th width="120" align="left" bgcolor="#808080" valign="top" style="border-color: #FFFF00"><b>SPC</b></th>
        <td width="70" align="left" bgcolor="#808080" valign="top">$0D </td>
        <td align="left" bgcolor="#808080" width="70" valign="top">1</td>
        <td align="left" bgcolor="#808080" width="800" valign="top">This is a <b>byte</b> which indicates the number of sectors per cluster on the disk. 
          Must be a power of 2 (usually 2)</td>
      </tr>
      <tr>
        <th width="120" align="left" bgcolor="#808080" valign="top" height="42" style="border-color: #FFFF00"> <b>RESSEC</b></th>
        <td width="70" align="left" bgcolor="#808080" valign="top" height="42">$0E </td>
        <td align="left" bgcolor="#808080" width="70" valign="top" height="42">2</td>
        <td align="left" bgcolor="#808080" width="800" valign="top" height="42">This is an 
          Intel format <b>word</b> which indicates the number of reserved sectors 
          at the beginning of the media preceding the start of the first FAT, 
          including the boot sector itself. It is usually one for floppies.</td>
      </tr>
      <tr>
        <th width="120" align="left" bgcolor="#808080" valign="top" style="border-color: #FFFF00"><b>NFATS</b></th>
        <td width="70" align="left" bgcolor="#808080" valign="top">$10 </td>
        <td align="left" bgcolor="#808080" width="70" valign="top">1</td>
        <td align="left" bgcolor="#808080" width="800" valign="top">This is a <b>byte</b> indicating the number of File Allocation Table's (FAT's) stored 
          on the disk. Usually the value is two as one extra copy of the FAT is 
          kept to recover data if the first FAT gets corrupted.</td>
      </tr>
      <tr>
        <th width="120" align="left" bgcolor="#808080" valign="top" style="border-color: #FFFF00"><b>NDIRS</b></th>
        <td width="70" align="left" bgcolor="#808080" valign="top">$11 </td>
        <td align="left" bgcolor="#808080" width="70" valign="top">2</td>
        <td align="left" bgcolor="#808080" width="800" valign="top">This is an 
          Intel format <b>word</b> indicating the total number of file name 
          entries that can be stored in the root directory of the volume.</td>
      </tr>
      <tr>
        <th width="120" align="left" bgcolor="#808080" valign="top" style="border-color: #FFFF00"><b>NSECTS</b></th>
        <td width="70" align="left" bgcolor="#808080" valign="top">$13 </td>
        <td align="left" bgcolor="#808080" width="70" valign="top">2</td>
        <td align="left" bgcolor="#808080" width="800" valign="top">This is an 
          Intel format <b>word</b> indicating the number of sectors on the disk 
          (including those reserved). </td>
      </tr>
      <tr>
        <th width="120" align="left" bgcolor="#808080" valign="top" style="border-color: #FFFF00"><b>MEDIA</b></th>
        <td width="70" align="left" bgcolor="#808080" valign="top">$15 </td>
        <td align="left" bgcolor="#808080" width="70" valign="top">1</td>
        <td align="left" bgcolor="#808080" width="800" valign="top">This <b>byte</b> is the media descriptor. For hard disks this value is set to 0xF8, otherwise it 
          is unused on Atari. </td>
      </tr>
      <tr>
        <th width="120" align="left" bgcolor="#808080" valign="top" style="border-color: #FFFF00"><b>SPF</b></th>
        <td width="70" align="left" bgcolor="#808080" valign="top">$16 </td>
        <td align="left" bgcolor="#808080" width="70" valign="top">2</td>
        <td align="left" bgcolor="#808080" width="800" valign="top">This is an 
          Intel format <b>word</b> indicating the number of sectors occupied by 
          each of the FATs on 
          the volume. Given this information, together with the number of FATs and 
          reserved sectors listed above, we can compute where the <a href="#fd_soft_directory"> <i>root directory</i> </a>begins. Given the number of entries in the root directory, we can also 
          compute where the user data area of the disk begins.</td>
      </tr>
      <tr>
        <th width="120" align="left" bgcolor="#808080" valign="top" style="border-color: #FFFF00"><b>SPT</b></th>
        <td width="70" align="left" bgcolor="#808080" valign="top">$18 </td>
        <td align="left" bgcolor="#808080" width="70" valign="top">2</td>
        <td align="left" bgcolor="#808080" width="800" valign="top">This is an 
          Intel format <b>word</b> indicating the number of sectors per track 
          (usually 9)</td>
      </tr>
      <tr>
        <th width="120" align="left" bgcolor="#808080" valign="top" style="border-color: #FFFF00"><b>NHEADS</b></th>
        <td width="70" align="left" bgcolor="#808080" valign="top">$1A </td>
        <td align="left" bgcolor="#808080" width="70" valign="top">2</td>
        <td align="left" bgcolor="#808080" width="800" valign="top">This is an 
          Intel format <b>word</b> indicating the number of heads on the disk. For 
          a single side diskette the value is 1 and for a double sided diskette 
          the value is&nbsp; 2.</td>
      </tr>
      <tr>
        <th width="120" align="left" bgcolor="#808080" valign="top" style="border-color: #FFFF00"><b>NHID</b></th>
        <td width="70" align="left" bgcolor="#808080" valign="top">$1C </td>
        <td align="left" bgcolor="#808080" width="70" valign="top">2</td>
        <td align="left" bgcolor="#808080" width="800" valign="top">This is an 
          Intel format <b>word</b> indicating the number of hidden sectors on a 
          disk (not used by Atari). </td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" bgcolor="#FFCC00" style="border-color: #FFFF00"> <font color="#000000">EXECFLAG</font></th>
        <td width="70" align="left" valign="top" bgcolor="#FFCC00"><font color="#000000">$1E</font></td>
        <td align="left" width="70" valign="top" bgcolor="#FFCC00"><font color="#000000">2</font></td>
        <td align="left" width="800" valign="top" bgcolor="#FFCC00"><font color="#000000">This is&nbsp; 
          a<b> word </b>which is loaded in the <b>cmdload </b>system 
          variable. This flag is used to find out if the command.prg program has 
          to be started after loading the OS.</font></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" bgcolor="#FFCC00" style="border-color: #FFFF00"> <font color="#000000">LDMODE</font></th>
        <td width="70" align="left" valign="top" bgcolor="#FFCC00"><font color="#000000">$20</font></td>
        <td align="left" width="70" valign="top" bgcolor="#FFCC00"><font color="#000000">2</font></td>
        <td align="left" width="800" valign="top" bgcolor="#FFCC00"><font color="#000000">This is&nbsp; 
          a <b>word </b>indicating the load mode. If this flag equal zero 
          the file specified by the FNAME field is located and loaded (usually the file is TOS.IMG). If the flag is not equal to zero the sectors as 
          specified by SECTCNT and SSSECT variables are loaded.</font></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" bgcolor="#FFCC00" style="border-color: #FFFF00"> <font color="#000000">SSECT</font></th>
        <td width="70" align="left" valign="top" bgcolor="#FFCC00"><font color="#000000">$22</font></td>
        <td align="left" width="70" valign="top" bgcolor="#FFCC00"><font color="#000000">2</font></td>
        <td align="left" width="800" valign="top" bgcolor="#FFCC00"><font color="#000000">This is&nbsp; 
          an Intel format <b>word </b>indicating the logical sector from where we 
          boot. This variable is only used if LDMODE is not equal to zero</font></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" bgcolor="#FFCC00" style="border-color: #FFFF00"> <font color="#000000">SECTCNT</font></th>
        <td width="70" align="left" valign="top" bgcolor="#FFCC00"><font color="#000000">$24</font></td>
        <td align="left" width="70" valign="top" bgcolor="#FFCC00"><font color="#000000">2</font></td>
        <td align="left" width="800" valign="top" bgcolor="#FFCC00"><font color="#000000">This is&nbsp; 
          an Intel format <b>word </b>indicating the number of sectors to load for 
          the boot. This variable is only used if LDMODE is not equal to zero</font></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" bgcolor="#FFCC00" style="border-color: #FFFF00"> <font color="#000000">LDAADDR</font></th>
        <td width="70" align="left" valign="top" bgcolor="#FFCC00"><font color="#000000">$26</font></td>
        <td align="left" width="70" valign="top" bgcolor="#FFCC00"><font color="#000000">2</font></td>
        <td align="left" width="800" valign="top" bgcolor="#FFCC00"><font color="#000000">This is&nbsp; 
          an Intel format <b>word </b>indicating the memory address where the boot 
          program will be loaded.</font></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" bgcolor="#FFCC00" style="border-color: #FFFF00"> <font color="#000000">FATBUF</font></th>
        <td width="70" align="left" valign="top" bgcolor="#FFCC00"><font color="#000000">$2A</font></td>
        <td align="left" width="70" valign="top" bgcolor="#FFCC00"><font color="#000000">2</font></td>
        <td align="left" width="800" valign="top" bgcolor="#FFCC00"><font color="#000000">This is&nbsp; 
          an Intel format <b>word </b>indicating the address where the FAT and 
          catalog sectors must be loaded</font></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" bgcolor="#FFCC00" style="border-color: #FFFF00"> <font color="#000000">FNAME</font></th>
        <td width="70" align="left" valign="top" bgcolor="#FFCC00"><font color="#000000">$2E</font></td>
        <td align="left" width="70" valign="top" bgcolor="#FFCC00"><font color="#000000">11</font></td>
        <td align="left" width="800" valign="top" bgcolor="#FFCC00"><font color="#000000">This is the 
          name of an image file that must be loaded when LDMODE equal zero. It has 
          exactly the same structure as a normal file name, that is 8 characters 
          for the name and 3 characters for the extension.</font></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" bgcolor="#FFCC00" style="border-color: #FFFF00"> <font color="#000000">RESERVED</font></th>
        <td width="70" align="left" valign="top" bgcolor="#FFCC00"><font color="#000000">$39</font></td>
        <td align="left" width="70" valign="top" bgcolor="#FFCC00"><font color="#000000">2</font></td>
        <td align="left" width="800" valign="top" bgcolor="#FFCC00"><font color="#000000">Reserved</font></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" bgcolor="#FFCC00" style="border-color: #FFFF00"> <font color="#000000">BOOTIT</font></th>
        <td width="70" align="left" valign="top" bgcolor="#FFCC00"><font color="#000000">$3A</font></td>
        <td align="left" width="70" valign="top" bgcolor="#FFCC00"><font color="#000000">452</font></td>
        <td align="left" width="800" valign="top" bgcolor="#FFCC00"><font color="#000000">Boot program 
          that can eventually be loaded after loading of the boot sector.</font></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00"><b>CHECKSUM</b></th>
        <td width="70" align="left" valign="top">$1FE </td>
        <td align="left" width="70" valign="top">2</td>
        <td align="left" width="800" valign="top">The entire boot sector <b>word</b> summed with this Motorola format <b>word</b> will equal 0x1234 if the 
          boot sector is executable or some other value if not. </td>
      </tr>
    </table>
<p>The data beginning at offset $1E (<font color="#000000"><span style="background-color: #FFCC00">colored in yellow</span></font>) are only used for a 
      <b>bootable diskette</b>. To recognize that a diskette is bootable the boot sector must contain the text &quot;Loader&quot; starting at the third bytes 
        and the sum of the entire boot sector should be equal to $1234.</p>
<p>The boot process is usually done in 4 stages:</p>
<ol>
  <li>The boot sector is loaded and the boot program contained is executed.</li>
  <li>The FAT and the catalog are loaded from the diskette and the loader 
    search for the file name indicated</li>
  <li>The program image is loaded usually starting with address $40000</li>
  <li>The loaded program is executed from the beginning.</li>
</ol>
<p>See also some <a href="/atari/software/fd-soft/bootsector.txt">Boot sector code</a>.</p>
<ul>
  <li><a href="FD-Soft.php" class="btt"> Back to the top</a>
  </li>
  </ul>
<h2><a name="fd_soft_directory">Directory Structure</a></h2>
<p>The TOS arranges and stores file-system contents in directories. Every file system has at least one directory, called the <b>root directory </b>(also 
  referred as the catalog in Atari), and may have additional directories either in the root directory or ordered hierarchically below it. The contents 
  of each directory are described in individual directory entries. The TOS strictly controls the format and content of directories.<br>
  The <b>root directory </b>is always the topmost directory. The TOS creates the root directory when it formats the storage medium (
  <a href="#fd_soft_getting_fd_ready">high level formatting</a>). The root directory can hold information for only a <u>fixed number 
    of files or other directories</u>, and the number cannot be changed without reformatting the medium. A program can identify this limit by examining 
  the <b>NDIRS </b>field in the BPB structure described in the <a href="#fd_soft_bs">boot sector</a> section. This field specifies the maximum 
  number of root-directory entries for the medium.<br>
  A user or a program program can add new directories within the current directory, or within other directories. Unlike the root directory, the new 
  directory is limited only by the amount of space available on the medium, not by a fixed number of entries. The TOS initially allocates only a 
  single cluster for the directory, allocating additional clusters only when they are needed. Every directory except the root directory has two 
  entries when it is created. The first entry specifies the directory itself, and the second entry specifies its parent directory—the directory that 
  contains it. These entries use the special directory names &quot;. &quot;(an ASCII period) and &quot;..&quot; (two ASCII periods), respectively.</p>
<p>The TOS gives programs access to files in the file system. Programs can read from and write to existing files, as well as create new ones. Files 
  can contain any amount of data, up to the limits of the storage medium. Apart from its contents, every file has a name (possibly with an extension), 
  access attributes, and an associated date and time. This information is stored in the file's directory entry, not in the file itself.</p>
<p>The <b><font color="#00FF00">root directory </font></b>is located just after the <a href="#fd_soft_fat">FATs</a> (i.e. on a single sided FD: 
  side 0, track 1, sector 3 and on DS DF side 1, track 0, sector 3) and is composed of 7 sectors. Each entry in the root directory can be describe by the 
  following structure:</p>
    <table border="2" cellspacing="0" bordercolor="#FFFF00" id="table44">
      <tr>
        <th align="left" width="120" style="border-color: #FFFF00">Name</th>
        <th align="left" width="70" style="border-color: #FFFF00">Bytes</th>
        <th align="left" width="800" style="border-color: #FFFF00"><b>Contents</b></th>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00">FNAME</th>
        <td align="left" width="70" valign="top">8</td>
        <td align="left" width="800" valign="top">Specifies the name of the file or directory. If the file or directory was created by using a name with 
          fewer than eight characters, space characters (ASCII $20) fill the remaining bytes in the field. The first byte in the field can be a 
          character or one of the following values:
          <ul>
            <li>$00 The directory entry has never been used. The TOS uses this value 
              to limit the length of directory searches.</li>
            <li>$05 The first character in the name has the value 0E5h.</li>
            <li>$2E The directory entry is an alias for this directory or the 
              parent directory. If the remaining bytes are space characters (ASCII 20h), the <b>SCLUSTER</b> field contains the starting cluster for 
              this directory. If the second byte is also 2Eh (and the remaining bytes are space characters), <b>SCLUSTER</b> contains the starting 
            cluster number of the parent directory, or zero if the parent is the root directory.</li>
            <li>E5h The file or directory has been deleted.</li>
          </ul></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00">FEXT</th>
        <td align="left" width="70" valign="top">3</td>
        <td align="left" width="800" valign="top">Specifies the file or directory extension. If the extension has fewer than three characters, 
        space characters (ASCII $20) fill the remaining bytes in this field.</td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00">ATTRIB</th>
        <td align="left" width="70" valign="top">1</td>
        <td align="left" width="800" valign="top">Specifies the attributes of 
          the file or directory. This field can contain some combination of the 
          following values:
          <ul>
            <li>&nbsp;$01 Specifies a read-only file.</li>
            <li>&nbsp;$02 Specifies a hidden file or directory.</li>
            <li>&nbsp;$04 Specifies a system file or directory.</li>
            <li>&nbsp;$08 Specifies a volume label. The directory entry contains no other usable information (except for date and time of creation) 
            and can occur only in the root directory.</li>
            <li>&nbsp;$10 Specifies a directory.</li>
            <li>&nbsp;$20 Specifies a file that is new or has been modified.</li>
            <li>&nbsp;All other values are reserved. (The two high-order bits are set to zero.) If no attributes are set, the file is a normal file.</li>
          </ul></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00">RES</th>
        <td align="left" width="70" valign="top">10</td>
        <td align="left" width="800" valign="top">Reserved; do not use.</td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00">FTIME</th>
        <td align="left" width="70" valign="top">2</td>
        <td align="left" width="800" valign="top">Specifies the time the file or 
          directory was created or last updated. The field has the following form:
          <ul>
            <li>&nbsp;bits 0-4 Specifies two-second intervals. Can be a value in 
              the range 0 through 29.</li>
            <li>&nbsp;bits 5-10 Specifies minutes. Can be a value in the range 0 
              through 59.</li>
            <li>&nbsp;bits 11-15 Specifies hours. Can be a value in the range 0 
              through 23.</li>
          </ul></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00">FDATE</th>
        <td align="left" width="70" valign="top">2</td>
        <td align="left" width="800" valign="top">Specifies the date the file or 
          directory was created or last updated. The field has the following form:
          <ul>
            <li>&nbsp;bits 0-4 Specifies the day. Can be a value in the range 1 
              through 31.</li>
            <li>&nbsp;bits 5-8 Specifies the month. Can be a value in the range 
              1 through 12.</li>
            <li>&nbsp;bits 9-15 Specifies the year, relative to 1980.</li>
          </ul></td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00">SCLUSTER</th>
        <td align="left" width="70" valign="top">2</td>
        <td align="left" width="800" valign="top">Specifies the starting cluster 
          of the file or directory (index into the <a href="#fd_soft_fat">FAT</a>)</td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00">FSIZE</th>
        <td align="left" width="70" valign="top">4</td>
        <td align="left" width="800" valign="top">Specifies the maximum size of 
          the file, in bytes.</td>
      </tr>
    </table>
    <ul>
      <li><a href="FD-Soft.php" class="btt"> Back to the top</a>
      </li>
    </ul>
    <h2><a name="fd_soft_fat">FAT Structure</a></h2>
    <p>The file allocation table (FAT) is an array used by the TOS to keep track of 
        which clusters on a drive have been allocated for each file or directory. As a 
        program creates a new file or adds to an existing one, the system allocates 
        sectors for that file, writes the data to the given sectors, and keeps track of 
        the allocated sectors by recording them in the FAT. To conserve space and speed 
        up record-keeping, each record in the FAT corresponds to two or more consecutive 
        sectors (called a cluster). The number of sectors in a cluster depends on the 
        type and capacity of the drive but is always a power of 2. Every logical drive 
        has at least one FAT, and most drives have two, one serving as a backup should 
        the other fail. The FAT immediately follows the <a href="#fd_soft_bs">boot 
          sector </a>and any other reserved sectors.</p>
    <p>Depending on the number of clusters on the drive, the FAT consists of an 
        array of either 12-bit or 16-bit entries. Drives with more than 4086 clusters 
        have a 16-bit FAT; those with 4086 or fewer clusters have a 12-bit FAT. As Atari 
        diskette has always less than 4086 clusters the FATs<b>on 
          Atari diskettes are always 
          12-bit FATs</b>.</p>
    <p>The first two entries in a FAT (3 bytes for a 12-bit FAT) are reserved. In 
        most cases the first byte contains the media descriptor (usually $F9F) and the 
        additional reserved bytes are set to $FFF. Each FAT entry represents a corresponding cluster on the drive. If the cluster 
        is part of a file or directory, the entry contains either a marker specifying 
        the cluster as the last in that file or directory, or an index pointing to the 
        next cluster in the file or directory. If a cluster is not part of a file or 
        directory, the entry contains a value indicating the cluster's status. </p>
    <p>The following table shows possible FAT entry values:</p>
    <table border="1" bordercolor="#FFFF00" id="table45">
      <tr>
        <th align="left" width="120" style="border-color: #FFFF00">Value</th>
        <th align="left" width="800" style="border-color: #FFFF00">Meaning</th>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00">$000</th>
        <td align="left" width="800" valign="top">Available cluster.</td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00">$002-$FEF</th>
        <td align="left" width="800" valign="top">Index of entry for the next 
          cluster in the file or directory. Note that $001 does not appear in a 
          FAT, since that value corresponds to the FAT's second reserved entry. 
          Index numbering is based on the beginning of the FAT</td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" height="24" style="border-color: #FFFF00">$FF0-$FF6</th>
        <td align="left" width="800" valign="top" height="24">Reserved</td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00">$FF7</th>
        <td align="left" width="800" valign="top">Bad sector in cluster; do not 
          use cluster.</td>
      </tr>
      <tr>
        <th width="120" align="left" valign="top" style="border-color: #FFFF00">$FF8-$FFF</th>
        <td align="left" width="800" valign="top">Last cluster of file or 
          directory. (usually the value $FFF is used)</td>
      </tr>
    </table>
    <p>Each file and directory consists of one or more clusters, each cluster 
        represented by a single entry in the FAT. The <b>SCLUSTER</b> field in the <a href="#fd_soft_directory"><i>directories</i> <i>structure</i></a> corresponding to the file or directory specifies the index of the first FAT 
        entry for the file or directory. This entry contains $FFF if there are no 
        further FAT entries for that file or directory, or it contains the index of the 
        next FAT entry for the file or directory. For example, the following segment of 
        a 12-bit FAT shows the FAT entries for a file consisting of four clusters:</p>
    <ul>
      <li>&nbsp;$003 Cluster 2 points to cluster 3</li>
      <li>&nbsp;$005 Cluster 3 points to cluster 5</li>
      <li>&nbsp;$FF7 Cluster 4 contains a bad sector</li>
      <li>&nbsp;$006 Cluster 5 points to cluster 6</li>
      <li>&nbsp;$FFF Cluster 6 is the last cluster for the file</li>
      <li>&nbsp;$000 Clusters 7 is available</li>
      <li>&nbsp;...</li>
    </ul>
    <p>Note that if a cluster contains $000 it does not mean that it is empty but 
        that it is available. This is due to the fact that when a file is deleted the 
        data are not erased but only the first letter of the name of the file in the 
        directory structure is set to $E5 and all clusters used by the deleted file are 
        set to $000.</p>
    <p><a href="FD-Soft.php" class="btt"> Back to the top</a>
    </p>
<h1><a name="fd_soft_images">Atari Floppy Disk Images</a></h1>
<ul>
  <li><a href="#fd_soft_image_formats">Disk Image Formats</a></li>
  <li><a href="#format_emul">Format Supported by Emulators</a></li>
  <li><a href="#fd_soft_images_from_floppies">Making disk images from FDs</a></li>
  <li><a href="#fd_soft_floppies_from_images">Making FDs from disk images</a></li>
  <li><a href="#fd_soft_image_utilities">Disk Image Utilities</a>    </li>
  </ul>
<p>This section is also related to the<a href="/atari/software/preservation.php"> Atari FD Preservation section</a>.</p>
<h2> <a name="fd_soft_image_formats">Disk Image formats</a></h2>
<p>Disk images are usually used by SW or HW emulators. There are a lot of sites dedicated to the subject of Atari SW emulation and I will 
  therefore point you to a <a href="../links.php#links_emulators">list of links</a> on 
  the subject. For example <a href="http://emulatari.free.fr/appz.html">Emulateurs &amp; TOS</a> (in French!). </p>
<p>The most famous and still maintained Atari Emulators running on PC are <a href="http://hatari.berlios.de/">Hatari</a>, <a href="http://steem.atari.st/">Steem</a>, and <a href="http://steem.atari.st/">Saint</a>. In order to run an emulator you need a <b><a href="http://www.fortunecity.com/tattooine/canaveral/157/">TOS ROM</a></b> also not covered here<b>.</b> There is also  the <a href="http://hxc2001.free.fr/floppy_drive_emulator/index.html">HxC2001 Universal FD Drive Emulator</a> that can be used on real Atari.</p>
<p>      The major  disk image formats used by the 
  Atari emulators are:
</p>
<ul>
  <li><b>ST</b> : Supported by all emulators, it is the most 
    simple format since it’s a straight copy of the readable data of a disk. 
    Created originally for the <a href="http://www.atari.st/pacifist/">PacifiST</a> emulator, it does not allow copying copy-protected disks.</li>
  <li><b>MSA</b> : An acronym 
    for Magic Shadow Archiver, 
    it is a format created on Atari by the compression program of the same name. This format, is also supported by almost all emulators. It contains the same 
    data as the ST format, the only difference is that the data is compressed. A 
    variation of the program on Atari allows saving the data without any 
    compression. This result in an ST file but with an MSA header. A nice 
    feature of the MSA program is that it allows to split an archive 
    into multiple files, thus facilitating the transfer of large disk images on 
    floppies.</li>
  <li><b>DIM </b>: <a href="/atari/software/fd-soft/dim-format.txt">A format</a> created by the well known Atari 
    copy program: &quot;FastCopy Pro&quot;. The non-compressed version of this 
    format contains the same information as the ST and MSA formats, but with a 
    proprietary header. This format is also supported by most emulators.</li>
  <li><b>STT </b>: Created and developed by the creators of <a href="http://steem.atari.st/">STeem</a> Engine 
    emulator, it is supposed to allow the copy of many original disks, including certain <a href="/atari/software/preservation.php#atari_protection">copy-protected games</a>.  It supports disks 
    of various numbers of tracks that can be of different size as well as other 
    details. For example it supports irregular sector numbers, sector numbers in range $F7-FF and 1 KB sectors.</li>
  <li><b>STX</b>: Created by the <a href="http://pasti.fxatari.com/">PASTI</a> initiative (Atari ST Imaging &amp; Preservation Tools). The imaging 
    tools <b>can virtually create images of any ST disk including <a href="/atari/software/preservation.php#atari_protection">copy protected 
      disks</a></b>. The STX Images can be used by the <a href="http://steem.atari.st/">STeem</a> and <a href="http://leonard.oxg.free.fr/">SainT</a> emulators. There is also a plan to support it in the <a href="http://hatari.berlios.de/">Hatari</a> Emulator. Unfortunately Ijor has not published information on the STX format. However you can find information <a href="http://www.sarnau.info/atari:pasti_file_format">here,</a> <a href="http://atari.8bitchip.info/STXdesc.html">here</a>, and <a href="http://hxc2001.free.fr/floppy_drive_emulator/index.html#USBFloppyemulator">here</a> (you have to look into the source code).</li>
  <li><strong>IPF</strong>: Created by the <a href="http://www.softpres.org/">Software Preservation Society</a> (SPS). -- The provided DCT imaging 
    tool <b>can  create images of any ST disk including <a href="/atari/software/preservation.php#atari_protection">copy protected 
      disks</a></b>. This format is &quot;new&quot; to the Atari scene and support in emulators is not yet available.</li>
  </ul>
<p>Note also that most recent emulators like <a href="http://steem.atari.st/">STeem</a> can directly read <b>zipped disk 
  images</b>. For example STeem or Hatari can mount directly a zipped file (.zip) that contains 
  a disk image of any of the supported disk image format.</p>
<h2><a name="format_emul" id="format_emul"></a>Formats supported by Emulators</h2>
<p>The following table summurize the supported formats for each emulators:</p>
<p>&nbsp;</p>
    <table width="75%" border="1" align="center">
      <tr>
        <th width="100" scope="col">&nbsp;</th>
        <th width="100" align="center" scope="col">ST</th>
        <th width="100" align="center" scope="col">MSA</th>
        <th width="100" align="center" scope="col">DIM</th>
        <th width="100" align="center" scope="col">STT</th>
        <th width="100" align="center" scope="col">STX</th>
        <th width="100" align="center" scope="col">IPF</th>
      </tr>
      <tr>
        <th width="100" scope="row">Hatari</th>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">&nbsp;</td>
        <td width="100" align="center">&nbsp;</td>
        <td width="100" align="center">&nbsp;</td>
      </tr>
      <tr>
        <th width="100" scope="row">Steem</th>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">&nbsp;</td>
      </tr>
      <tr>
        <th width="100" scope="row">Saint</th>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">&nbsp;</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">&nbsp;</td>
      </tr>
      <tr>
        <th width="100" scope="row">USB HxC</th>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
      </tr>
      <tr>
        <th width="100" scope="row">SD HxC</th>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">Yes</td>
        <td width="100" align="center">No VBR</td>
        <td width="100" align="center">No VBR</td>
      </tr>
    </table>
    <p>&nbsp;</p>
    <p><a href="FD-Soft.php" class="btt"> Back to the top</a>
    </p>
    <h2><a name="fd_soft_images_from_floppies">Making Disk Images from ST Original Floppies</a></h2>
    <p>This section try to answer the question: <i>I have  Atari floppies that I want to use with my favorite emulator...</i></p>
<ul>
      <li>&nbsp;Making <b>ST</b> Disk Images (Only on a PC):<br>
      To make ST images on a <em>Windows</em> system the best solution is to use the <a href="http://atari.8bitchip.info/floimgd.php">Floppy Imaging &amp; File transfer</a> (<strong>FloImg</strong>) program from <strong>P. Putnik</strong>.You can also use <a href="../programs/imaging/makedisk_v15.zip">Makedisk</a> (DOS), <a href="../programs/imaging/imgbuild.zip">imgbuild</a> (DOS), <a href="../programs/imaging/wfdcopy-1.03.zip">wfdcopy</a> (Windows 95/98 you will have problem on XP/7). 
        Instruction can be found at <a href="http://emulatari.free.fr/">Mr Nours 
          site</a>.        I have tested these three program successfully on simples non 
        protected FD without problem. 
        Although it should be possible to use the <a href="http://www.emulators.com/download.htm">gemulator</a> explorer to 
        create disk images but it did not worked for me. </li>
      <li>&nbsp;Making <b>MSA</b> Images (On PC and Atari ST):<br>
        To make MSA images on a <em>Windows</em> system the best solution is to use the <a href="http://atari.8bitchip.info/floimgd.php">Floppy Imaging &amp; File transfer</a> (<strong>FloImg</strong>) program from <strong>P. Putnik</strong>. On Atari I have made the tests with <a href="../programs/imaging/MSA2_3.PRG">MSA II - 
          V2.3</a>. The process is straightforward : start the program specify the 
        name and directory for the image, indicate if you want the file to be 
        compressed or not and click the &quot;Disk -&gt; File&quot; button ... and you are done. 
        You should use compressed mode to get smaller disk images.</li>
      <li>&nbsp;Making <b>DIM</b> Disk Image (On  Atari ST):<br>
        First you need the <a href="../programs/disk/fcopypro.zip">FastCopy <b>Pro</b></a> version (version &quot;no version&quot;, or <a href="../programs/disk/fcopypro.zip">1.0</a> or 1.2 did work for me). <strong>Important</strong> if you are using the version &quot;without version&quot; 
        number you <b>must first </b>select<b> </b>the<b> &quot;all&quot; </b>option<b> </b>from the get sectors choice, in V1.0 and 1.2 this choice is unavailable 
        (always pre-selected to all). After that you need to click on the &quot;image 
        copy&quot; button, then select the &quot;read&quot; button and enter the name of the file 
        you want to create... This file should be directly readable by the 
        emulators.</li>
      <li>&nbsp;Making <b>STT</b> Disk Images (On PC or   Atari ST):<br>
        To make STT images on a <em>Windows</em> system the best solution is to use the <a href="http://atari.8bitchip.info/floimgd.php">Floppy Imaging &amp; File transfer</a> (<strong>FloImg</strong>) program from <strong>P. Putnik</strong>. On Atari use the <a href="http://steem.atari.st/">STeem</a> Disk Imager that comes 
        with STeem itself. Instructions are provided in the disk image howto.txt 
        file. The <b>STT</b> image can be mounted by <a href="http://steem.atari.st/">STeem</a> only.</li>
      <li>&nbsp;Making <b>STX</b> Disk Images of <a href="/atari/software/preservation.php#atari_protection">copy protected disk</a> (On Atari ST):<br>
        Instruction on making STX images can be found in the Alone in the paST <a href="http://www.aitpast.com/index.php">AitpaST</a> site.</li>
      <li>Making <strong>IPF</strong> Disk Image of <a href="/atari/software/preservation.php#atari_protection">copy protected disk</a> -- TODO</li>
    </ul>
<p><a href="FD-Soft.php" class="btt"> Back to the top</a>
</p>
<h2><a name="fd_soft_floppies_from_images">Making ST Floppies from Disk Image files</a></h2>
<p>This section try to answer the question: <i>I have some interesting disk images that I 
  would like to run from a FD on my real Atari...</i></p>
<ul>
  <li>&nbsp;Making a floppy disk from a<b> ST</b> image (Only on PC):<br>
    On a <em>Windows</em> system the best solution is to use the <a href="http://atari.8bitchip.info/floimgd.php">Floppy Imaging &amp; File transfer</a> (<strong>FloImg</strong>) program from <strong>P. Putnik</strong> to write ST images on an actual FD. You can also use <a href="../programs/imaging/makedisk_v15.zip">makedisk</a> (DOS), or <a href="http://www.8hz.com/stdisk/">ST Disk</a> (DOS), or <a href="../programs/imaging/wfdcopy-1.03.zip">wfdcopy</a> (Windows 95/98 you will have problem on XP/7). 
    Instruction can be found at the <a href="http://emulatari.free.fr/">Mr Nours 
      site</a>.</li>
  <li>&nbsp;Making a floppy disk from a <b>MSA</b> image (On PC or  Atari ST):<br>
    On a <em>Windows</em> system the best solution is to use the <a href="http://atari.8bitchip.info/floimgd.php">Floppy Imaging &amp; File transfer</a> (<strong>FloImg</strong>) program from <strong>P. Putnik</strong> to write ST images on an actual FD. I have made the tests with <a href="../programs/imaging/MSA2_3.PRG">MSA II - 
      V2.3</a>. The process is straightforward : start the program specify the 
    name and directory of the image, click the &quot;File -&gt; Disk&quot; button ... and you 
    should have your disk ready.</li>
  <li>&nbsp;Making a floppy disk from a <b>DIM</b> image (On Atari ST):<br>
    First you need the <a href="../programs/disk/fcopypro.zip">FastCopy <b>Pro</b></a> version (version &quot;no version&quot;, or <a href="../programs/disk/fcopypro.zip">1.0</a> or 1.2). you need to click on the &quot;image copy&quot; button, then select 
    the &quot;Restore&quot; button and enter the name of the image file...</li>
  <li>&nbsp;Making a floppy disk from a <b>STT</b> image (on PC or Atari ST):<br>
    This is only possible if no protection or specific protections have been used. Your best choice  is to use the 
    <a href="http://atari.8bitchip.info/floimgd.php">Floppy Imaging &amp; File transfer</a> (<strong>FloImg</strong>) program from <strong>P. Putnik. </strong>In some cases (when no protection are used)  it is possible to first convert the <strong>STT</strong> image to an <strong>ST</strong> or <strong>MSA</strong> image 
    using the <a href="http://msaconverter.free.fr/index.html">MSA converter</a> program, and from this converted image use one of the procedure described above.</li>
  <li>&nbsp;Making a floppy disk from a <b>STX</b> image:<br>
    It is not yet possible to <a href="/atari/software/preservation.php#copy_protected_disk">create a protected disk</a> from an STX image. The 
    reason is that protected disk uses specific data that cannot be written directly by the 
    Atari FD controller. 
    <strong>Might</strong> be possible in future with 
    the &quot;<a href="/atari/hardware/devices/dc.php">Discovery Cartridge</a>&quot; or the <a href="/atari/hardware/devices/kryoflux.php"> KryoFlux Board</a>.</li>
  <li>&nbsp;Making a floppy disk from a <b>IPF</b> image:<br />
    TODO - see the <a href="http://kryoflux.com/">KryoFlux</a> Project and the <a href="/atari/hardware/devices/kryoflux.php"> KryoFlux Board </a></li>
  <li><a href="FD-Soft.php" class="btt"> Back to the top</a>
  </li>
  </ul>
<h2><a name="fd_soft_image_utilities">Other PC Disk image utilities</a></h2>
<p>As already mentioned above, if you deal with disk images there is one program <b>you must have</b>:  the <a href="http://atari.8bitchip.info/floimgd.php">Floppy Imaging &amp; File transfer</a><a href="http://www.8bitchip.info/atari/floimgd.php"> program</a> (<strong>FloImg</strong>) from P. Putnik. This program can be used to create images in ST / MSA / STT format directly from a ST floppy placed in the PC Floppy Drive. It is also possible to create FD directly from images. It also support ST &lt;-&gt; to MSA conversion.</p>
<p>Another must have program is the <a href="http://msaconverter.free.fr/index.html">MSA 
  converter</a> that run under Windows. This program not only allow conversion between 
  different image formats but it also gives useful information about the image 
  content.<br>
  For information there are some older programs that run under DOS for <a href="../programs/imaging/sttomsa.zip">st to msa</a> conversion or from <a href="../programs/imaging/msatost.zip">msa to st</a> conversion. As well as 
  two DOS <a href="../programs/imaging/pc_st.zip">programs</a> to convert a PC disk 
  to/from an ST disk.</p>
<h1>Links</h1>
<ul>
  <li><a href="http://en.wikipedia.org/wiki/Disk_image">Disk Image</a> from Wikipedia</li>
  </ul>
<p>&nbsp;</p>
<p><a href="FD-Soft.php" class="btt"> Back to the top</a>
  
</p>
  </div>
<div id="footer">
    <h1>Copyright and Fair Use Notice </h1>
    <p>This site contains copyrighted material the use of which has not 
      always been specifically authorized by the copyright owner. We are making such 
      material available in our efforts to help in the understanding of&nbsp;the Atari 
      Computers. We believe this constitutes a 'fair use' of any such copyrighted 
      material. The material on this site is accessible without profit and is 
      presented here with the only goal to disseminate knowledge about Atari 
      computers. Consistent with this notice you are welcome to make 'fair use' of 
      anything you find on this web site. However, all persons reproducing, 
      redistributing, or making commercial use of this information are expected to 
      adhere to the terms and conditions asserted by the copyright holder. 
      Transmission or reproduction of protected items beyond that allowed by fair use 
      notice as defined in the copyright laws requires the permission of the copyright 
      owners. </p>
    <p>&copy; Info-Coach - DrCoolZic (Jean Louis-Guérin)</p>
  </div>
  <!-- end #footer --> 
</div>
</body>
</html>
