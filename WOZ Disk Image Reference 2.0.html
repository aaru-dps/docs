<!doctype html>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="profile" href="http://gmpg.org/xfn/11">

	<title>WOZ Disk Image Reference 2.0 &#8211; applesauce</title>
<link rel='dns-prefetch' href='//www.google.com' />
<link rel='dns-prefetch' href='//s.w.org' />
<link rel="alternate" type="application/rss+xml" title="applesauce &raquo; Feed" href="https://applesaucefdc.com/feed/" />
<link rel="alternate" type="application/rss+xml" title="applesauce &raquo; Comments Feed" href="https://applesaucefdc.com/comments/feed/" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/12.0.0-1\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/12.0.0-1\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/applesaucefdc.com\/wp-includes\/js\/wp-emoji-release.min.js?ver=5.2.2"}};
			!function(a,b,c){function d(a,b){var c=String.fromCharCode;l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,a),0,0);var d=k.toDataURL();l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,b),0,0);var e=k.toDataURL();return d===e}function e(a){var b;if(!l||!l.fillText)return!1;switch(l.textBaseline="top",l.font="600 32px Arial",a){case"flag":return!(b=d([55356,56826,55356,56819],[55356,56826,8203,55356,56819]))&&(b=d([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]),!b);case"emoji":return b=d([55357,56424,55356,57342,8205,55358,56605,8205,55357,56424,55356,57340],[55357,56424,55356,57342,8203,55358,56605,8203,55357,56424,55356,57340]),!b}return!1}function f(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var g,h,i,j,k=b.createElement("canvas"),l=k.getContext&&k.getContext("2d");for(j=Array("flag","emoji"),c.supports={everything:!0,everythingExceptFlag:!0},i=0;i<j.length;i++)c.supports[j[i]]=e(j[i]),c.supports.everything=c.supports.everything&&c.supports[j[i]],"flag"!==j[i]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[j[i]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(h=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",h,!1),a.addEventListener("load",h,!1)):(a.attachEvent("onload",h),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),g=c.source||{},g.concatemoji?f(g.concatemoji):g.wpemoji&&g.twemoji&&(f(g.twemoji),f(g.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
	<link rel='stylesheet' id='wp-block-library-css'  href='https://applesaucefdc.com/wp-includes/css/dist/block-library/style.min.css?ver=5.2.2' type='text/css' media='all' />
<link rel='stylesheet' id='contact-form-7-css'  href='https://applesaucefdc.com/wp-content/plugins/contact-form-7/includes/css/styles.css?ver=5.1.3' type='text/css' media='all' />
<link rel='stylesheet' id='miniva-style-css'  href='https://applesaucefdc.com/wp-content/themes/miniva/style.css?ver=5.2.2' type='text/css' media='all' />
<script type='text/javascript' src='https://applesaucefdc.com/wp-includes/js/jquery/jquery.js?ver=1.12.4-wp'></script>
<script type='text/javascript' src='https://applesaucefdc.com/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'></script>
<link rel='https://api.w.org/' href='https://applesaucefdc.com/wp-json/' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://applesaucefdc.com/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://applesaucefdc.com/wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 5.2.2" />
<link rel="canonical" href="https://applesaucefdc.com/woz/reference2/" />
<link rel='shortlink' href='https://applesaucefdc.com/?p=350' />
<link rel="alternate" type="application/json+oembed" href="https://applesaucefdc.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fapplesaucefdc.com%2Fwoz%2Freference2%2F" />
<link rel="alternate" type="text/xml+oembed" href="https://applesaucefdc.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fapplesaucefdc.com%2Fwoz%2Freference2%2F&#038;format=xml" />
		<style type="text/css">
					.site-title,
			.site-description {
				position: absolute;
				clip: rect(1px, 1px, 1px, 1px);
			}
		
						.site-header { background-image: url(https://applesaucefdc.com/wp-content/uploads/2018/06/header-1.png); }
					</style>
		<style type="text/css" id="custom-background-css">
body.custom-background { background-color: #ede2cf; }
</style>
			<style type="text/css" id="wp-custom-css">
			hr {
    margin-top: 48px;
    margin-bottom: 8px;
    border: 5;
    border-top: 2px solid #d44;
}		</style>
		</head>

<body class="page-template page-template-template-fullwidth page-template-template-fullwidth-php page page-id-350 page-child parent-pageid-59 custom-background posts-large logo-top menu-centered logo-default">

<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="display:none;">
	<symbol viewBox="0 0 16 16" id="search"><title>search</title> <path d="M14.7,13.3L11,9.6c0.6-0.9,1-2,1-3.1C12,3.5,9.5,1,6.5,1S1,3.5,1,6.5S3.5,12,6.5,12c1.2,0,2.2-0.4,3.1-1l3.7,3.7L14.7,13.3z
	 M2.5,6.5c0-2.2,1.8-4,4-4s4,1.8,4,4s-1.8,4-4,4S2.5,8.7,2.5,6.5z"/> </symbol>
</svg>

<div id="page" class="site">
	<a class="skip-link screen-reader-text" href="#content">Skip to content</a>

	
	<header id="masthead" class="site-header" role="banner">

		<div class="container">
		<div class="site-branding">

			
			<div class="site-branding-text">
									<p class="site-title"><a href="https://applesaucefdc.com/" rel="home">applesauce</a></p>
										<p class="site-description">Apple II Floppy Drive Controller</p>
							</div>
		</div><!-- .site-branding -->

		
		<nav id="site-navigation" class="main-navigation" role="navigation" aria-label="Primary">
			<button class="menu-toggle" aria-controls="primary-menu" aria-expanded="false">Menu</button>
			<ul id="primary-menu" class="primary-menu"><li id="menu-item-66" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-66"><a href="https://applesaucefdc.com/hardware/">Hardware</a></li>
<li id="menu-item-65" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-65"><a href="https://applesaucefdc.com/software/">Software</a></li>
<li id="menu-item-251" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-251"><a href="https://applesaucefdc.com/documentation/">Documentation</a></li>
<li id="menu-item-63" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-63"><a href="https://applesaucefdc.com/a2r/">A2R</a></li>
<li id="menu-item-64" class="menu-item menu-item-type-post_type menu-item-object-page current-page-ancestor menu-item-64"><a href="https://applesaucefdc.com/woz/">WOZ</a></li>
<li id="menu-item-420" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-420"><a href="https://applesaucefdc.com/order/">Order</a></li>
<li id="menu-item-34" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-34"><a href="https://applesaucefdc.com/contact/">Contact</a></li>
</ul>		</nav><!-- #site-navigation -->

		</div>
	</header><!-- #masthead -->

	
	<div id="content" class="site-content container">

		
	<div id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		

<article id="post-350" class="post-350 page type-page status-publish hentry post-single">

	
	<header class="entry-header">
		<h1 class="entry-title">WOZ Disk Image Reference 2.0</h1>	</header><!-- .entry-header -->

	
	<div class="entry-content">
		<p>Created by John K. Morris<br />
jmorris@evolutioninteractive.com</p>
<p>Version 2.0 &#8211; December 16, 2018</p>
<p>Version 1.0 of the WOZ Disk Image Reference can be found <a href="https://applesaucefdc.com/woz/reference1/">here</a>.</p>
<p>Many thanks to the people who helped me prepare this document for release:<br />
John Brooks, David Brown, Bill Martens, Sean McNamara,Â Antoine Vignau, Olivier Galibert and 4am</p>
<hr />
<h2>Why yet another Apple II disk image format?</h2>
<p>This is probably the question many of you reading this document are asking. It basically comes down to the simple fact that none of the currently existing formats accurately represent the way data is encoded on an Apple II floppy disk. There is a place for a format that is an accurate representation of a bitstream that is also the exact length of a track so that it can be looped correctly. And since we are creating a format, it is also a great time to ensure that we organize the data in the image file in a way that allows for easy unpacking with as little memory and processing overhead as possible &#8211; this provides more performant usage in hardware and software emulators.</p>
<hr />
<h2>What benefits come with using the WOZ format?</h2>
<p>We seem to be doing just fine with the current file formats, why would we want to support the WOZ format? The big benefit is being able to successfully run copy protected software if you follow the emulation guidelines presented in this document. The second benefit is that the WOZ format is actually much simpler to implement than many of the other disk image formats. WOZ files also contain metadata about the disk image &#8211; such as disk name, product name, publisher, system requirements and language &#8211; that you can use to display additional information in your emulator.</p>
<hr />
<h2>What has changed in the WOZ specification for the 2.0 release?</h2>
<p>After releasing Applesauce, the flood of software began that has enabled a lot of validation of the WOZ format. Unfortunately, a few short comings were uncovered with the initial format. There were also some requests made to improve the format. This document details the 2.x specification. The 2.0 format is intended to be a replacement of the 1.0 format.</p>
<h3>File Header Changes</h3>
<p>The file identifier (bytes 0-3 of the file) was changed from WOZ1 to WOZ2. This was done since there are a couple of fundamental changes made to the format and we need to make sure that new WOZ 2.0 files are only consumed by hardware and software that is explicitly compatible with these changes.</p>
<h3>INFO Chunk Changes</h3>
<p>New INFO fields are indicated by the &#8220;2&#8221; in the Vers field in the INFO Chunk section of this document.</p>
<p>There are now flags for indicating whether track 0 contains boot sectors for 16 and/or 13 sector hardware. The Apple disk controller card contains a ROM (P5) that performs the task of bootstrap loading track $00 sector $0 from the disk and running it. This is what happens when you reboot your machine or use PR#6. The code contained within that boot sector is then responsible for loading up the rest of the disk. When Apple originally came out with the Disk II, it only dealt with 13-sector disks and 5&amp;3 nibble encoding. When you booted the computer, the P5 ROM would look for the boot sector by identifying an address prolog with the nibble values D5 AA B5. Later on, with DOS 3.3, Apple introduced the 16-sector format along with 6&amp;2 nibble encoding. This new format also needed a revised P5 ROM, known as the P5A. Since the two formats aren&#8217;t compatible with each other, they chose to change the default address prolog nibbles to D5 AA 96. The problem with this is that disks in one format are basically invisible to disks and hardware using the other format since they aren&#8217;t looking for the correct address prolog. The WOZ format now contains a Boot Sector Format indicating whether a boot sector exists for 13 and/or 16 sector ROMs. This can help emulators detect which ROM is needed when booting a disk.</p>
<p>The Optimal Bit Timing is now provided. This value dictates the rate at which bits should be provided to the disk controller card. There are a several disks that use slightly non-standard bit timings. Most of these work just fine under emulation, but many of these disks load faster if the bits are provided at the correct speed.Â This value is in 125 nanosecond increments, so 8 is equal to 1 microsecond. And a standard bit rate for a 5.25 disk would be 32 (4Âµs), and a 3.5 would be 16 (2Âµs).</p>
<p>Another feature requested by emulator developers was to hoist some of the compatible hardware values from the META chunk and place it into the INFO chunk in an easier to parse format. So, there is now a Compatible Hardware bit field as well as a Required RAM one.</p>
<p>A Largest Track field was added in order to help emulators allocate a properly sized buffer for storing track data.</p>
<h3>TMAP Chunk Changes</h3>
<p>The order of the TMAP data for 3.5 disks has changed to make it more efficient to find the proper offset ((track &lt;&lt; 1) + side). The TMAP chunk is unchanged for 5.25 disks.</p>
<h3>TRKS Chunk Changes</h3>
<p>It turns out that there was a trick that was more effective than I thought possible. Most 5.25 disks end up using about 6300-6500 bytes of data per track, but this all depends on the speed of the drive when writing the disk. I allocated 6646 bytes to each track to make sure there was a good pad in there for disks that were purposely written at a slower speed to pack more data on a track. It seems like some disks (I&#8217;m looking at you Datasoft) had things turned down even more and were able to fit an amazing 6680 bytes of data on a track. This broke the WOZ track size limit by 34 bytes.</p>
<p>The TRKS chunk was modified in order to allow a variable number of 512-byte blocks to be allocated for each track. This will allow the WOZ format to remain as small as possible for &#8220;normal&#8221; 5.25 disks, but also be able to accommodate ones with larger track data requirements. This also allows for more optimal storage for 3.5 disks as each speed zone can have the track size tuned for it.</p>
<p>The write hints have also been removed from the TRKS chunk and moved to their own WRIT chunk.</p>
<h3>WRIT Chunk Addition</h3>
<p>A new WRIT chunk has been added to the WOZ specification in order to provide detailed instructions for programs wanting to write WOZ files back to a real floppy disk. Inclusion of this chunk in a WOZ file is optional.</p>
<h3>Freaking Out Like a MC3470 Changes</h3>
<p>Due to some new findings in the analysis of MC3470, there is a new recommended implementation that should more accurately model the proper behavior.</p>
<hr />
<h2>Implementation Details</h2>
<p>Integrating WOZ support with your product is more than just loading data from a new type of container. It is also about how that data is used. Yes, it is possible to just shovel bits from the WOZ right into your bitstream, and many disk images will work just fine like that. But, by taking the following guidelines into account, your implementation will enable disk functionality that is also compatible with all copy protection schemes. <i>Yes, this means you can run copy protected software in system and disk drive emulators without the need to crack it first!</i></p>
<h3>Cross-Track Synchronization</h3>
<p>When Steve Wozniak was hacking up Shugart drives to make the Disk II, one of the parts that he threw away was the sync sensor. The sync sensor involved a light source on one side of the disk with a sensor on the other. This sensor would allow the drive to know when it made a full revolution, as the disk media itself had a hole that would let the light pass though as it passed the sensor. It really wasnât a necessary part for Wozniakâs soft-sectored design that was going to be used for storing data on the disk.</p>
<p><img class=" wp-image-115 aligncenter" src="https://applesaucefdc.com/wp-content/uploads/2018/06/unsynced_and_synced-300x140.png" alt="" width="669" height="312" srcset="https://applesaucefdc.com/wp-content/uploads/2018/06/unsynced_and_synced-300x140.png 300w, https://applesaucefdc.com/wp-content/uploads/2018/06/unsynced_and_synced-768x357.png 768w, https://applesaucefdc.com/wp-content/uploads/2018/06/unsynced_and_synced-1024x477.png 1024w, https://applesaucefdc.com/wp-content/uploads/2018/06/unsynced_and_synced.png 1100w" sizes="(max-width: 669px) 100vw, 669px" /></p>
<h5 style="text-align: center;">A NORMAL UNSYNCHRONIZED DISK VS A SYNCHRONIZED ONE.</h5>
<p>When it came to businesses designing copy protection schemes, this was something that they could use to their advantage. The professional disk copiers could easily write out all tracks synchronized with each other, something that your average Apple II floppy drive couldnât do. Then, the software would read a known sector on a specific track and, when it jumped to a neighboring track, it could make sure that the first sector it encountered there was the one it expected. Later protection schemes even made track widths which were almost 2 standard tracks wide and were accurate to within 1 bit. As much as the disk copy programs tried, they could only sync up tracks by sheer luck.</p>
<p>To circumvent these kind of copy protection checks, the WOZ format uses a Track Map (see the âTMAP Chunkâ section below). This allows us to assign a track image to any number of quarter tracks on a disk. An entire disk could even be a single track if we wanted.</p>
<p>There are a couple of rules to follow with regards to changing tracks within the emulator:</p>
<p>Firstly, if the tracks you are changing between have matching values in the TMAP, then donât change the track data. This will prevent any hiccups in the bitstream and can be a good performance gain to boot.</p>
<p>The second rule is that you need to maintain a bit pointer into your bitstream. You always need to know which bit you are on. When you do change tracks, you need to start the new bitstream at the same relative bitstream position &#8211; you cannot simply start the pointer at the beginning of the stream. You need to maintain the illusion of the head being over the same area of the disk, just shifted to a new track.</p>
<p>Also be sure to account for the fact that track lengths are inconsistent on a disk due to fluctuations in drive speed. Something like this works well to maintain the relative position if your environment can work with 32-bit or greater values:</p>
<pre>new_position = current_position * new_track_length / current_track_length</pre>
<p>Remember to maintain the bit position even when on an empty track (TMAP value of 0xFF). Since the empty track has no data, and therefore no length, using a fake length of 51,200 bits (6400 bytes) works very well.</p>
<h3>Freaking Out Like a MC3470</h3>
<p>On the Apple II, floppy disk data is written to the disk based on a 4Âµs clock. Whenever there is a 1 bit to write, the polarity of the magnetic flux under the drive head is transitioned from its current state to the opposite. If a zero needs to be written out, the 4Âµs clock is skipped (no transition occurs).</p>
<p>The MC3470 chip is the heart of the Apple II floppy drive. It reads the magnetic flux pattern off the disk and sends out a pulse for every flux transition it sees. This gives us back our 1 bits and our 0 bits come from the 4Âµs clock going by with no pulse.</p>
<p>One of the nice features of the MC3470 is that it has an internal amplification system to adapt to the varying magnetic strengths of each disk. If it has a hard time reading the disk, it can turn up its amp until it finds the signal. It allows the drive to read a wide assortment of disks. The Apple II uses GCR encoding to store bits on the disk. It is a very efficient system that was used widely on many platforms, because it doesnât use clock bits to frame up your data bits, giving you more room to write data. This technique also has a drawback though, which is never being able to record more than two 0 bits in a row. It is why data on an Apple II is stored as nibbles instead of plain binary bytes.</p>
<p>One very popular copy protection is referred to as âfake bitsâ or âweak bitsâ &#8211; this technique is actually an exploit against the MC3470. It comes from the idea of what happens when we make it read more than two 0 bits in a row. What happens is that our poor MC3470 thinks that it is doing a bad job reading the disk and keeps trying to turn up its amp to find the flux signal. It does this until it gets to the point that it amplifies background electrical noise so much that it <i>thinks</i> that it sees a transition and sends out a false pulse, which the computer happily records as a 1 bit.</p>
<p>So, how can this failure be used as copy protection? The software developers simply put these blank fake bit areas on the disk where the software knows where to find them. It then reads some good nibbles followed by the fake bits area. This gives us some good nibbles followed by some random valued nibble. This in itself is not particularly useful until you do it multiple times and see that the random nibble changes every time you read it! If the value keeps changing, then you know that it isnât a copy of the disk. How does it know that? Because programs like Copy II+ and Locksmith will read those same good nibbles followed by the random nibble, and then they will promptly write out all of the nibble values that they captured, thinking that they are all good. The random nibble is no longer random, it will never change from the value that has been captured, and now the copy protected software will know that it is actually a copy.</p>
<p>So how does the WOZ format deal with this? Well, the first part of the problem isnât taken care of within the WOZ format itself. The WOZ format is an offshoot of the Applesauce Floppy Drive Controller project. The Applesauce has a way to determine when it is seeing these fake bits and changes the fake bits back to the 0 bits that existed on the original disk.</p>
<p>Now that we are back to having long runs of 0s in the bitstream, we now need to emulate the MC3470 freaking out about them. There are a couple factors that come into play with making an accurate representation of this behavior. For those of you familiar with the WOZ 1.0 specification, this recommended implementation behavior has changed.</p>
<p>The first factor is that there is a latency of up to 5Âµs from when the head sees a <strong>real</strong> transition to when it passes through the MC3470 filter, differentiator, pulse generator and finally sent out as a pulse. But it appears that <strong>fake</strong> transitions have a much shorter latency. Due to this, fake bits are introduced earlier into the pulse stream than you would expect. The second factor is to remember that the read head is an analog device and isn&#8217;t reading a single point on the disk surface, but actually one that has a radius of about 7.5Âµs. As long as it has a flux within its window, either coming or going, it remains happy. It is when there is nothing in this windows that it starts freaking out. This means that we are definitely in our happy place with two 0 bits as the interval between them is 12Âµs (vs the window diameter of 15Âµs). Even three 0 bits is fairly safe with an interval of 16Âµs (only needs to deal with 1Âµs of starting to freak out), but this will sometimes throw a fake bit.</p>
<p>So, knowing these things, the recommended way to implement this behavior is to maintain an 4-bit wide buffer for the bits coming out of the WOZ file. Every time a new bit needs to be outputted, shift the buffer left 1 bit and put the next bit from the WOZ into bit 0 of the buffer. Then send the value in bit 1 of the buffer. This will give us our desired latency. So, how do we know when to send in the random fake bits? If the value of our buffer is 0, then we randomly output a bit instead of sending bit 1.</p>
<pre>uint8_t head_window = 0;

uint8_t nextDiskBit() {
	head_window &lt;&lt;= 1;
	head_window |= getNextWozBit();
	if ((head_window &amp; 0x0f) != 0x00) {
		return (head_window &amp; 0x02) &gt;&gt; 1;
	} else {
		return fakeBit();
	}
}</pre>
<p>Of course, coming up with random values like this can be a bit processor intensive, so it is adequate to create a randomly-filled circular buffer of 32 bytes. We then just pull bits from this whenever we are in âfake bit modeâ. This buffer should also be used for empty tracks as designated with an 0xFF value in the TMAP Chunk (see below). You will want to have roughly 30% of the buffer be 1 bits.</p>
<h3>When Off Isnât Really Off</h3>
<p>Turning on the floppy drive motor and getting the disk up to its 300 RPM speed isnât a particularly fast operation. When it came to DOS, it used a simple mechanism to read a file: turn disk on, read data, turn disk off. This turned out to be a fairly slow process as it kept needing to spin up the disk when you were accessing multiple files. So, a simple hardware optimization was created that would use a timing circuit to delay the turning off of the motor for a period of 1 second. This way if you were reading a bunch of files in a row, the motor wouldnât actually turn off between them and you could access the files much quicker. Pretty clever!</p>
<p>When it came to the copy protection arms race, a mechanism as clever as this would of course end up being weaponized. In order to discourage people from boot tracing their software, several protections took to the idea of turning off the floppy drive motor <i>before</i> trying to read some sectors. The developers knew that the disk would still have almost 5 full revolutions before actually turning off, so it wasnât a problem. But, if the crackers stopped program execution in this area, then they would lose access to the next sectors being read since the drive would turn off automatically after 1 second.</p>
<p>Therefore, a 1 second delay after accessing the âdrive motor offâ soft-switch at $C088,X needs to be implemented to allow software to continue reading sectors.</p>
<h3>Abusing Disk Controller Soft Switches for Fun and Profit</h3>
<p>The floppy drive is accessed by using the soft switches associated with the floppy disk controller card. These are in the range $C0x0-C0xF, with the value of x being $8 + the slot number. All of these switches have a specific function like turning the motor on/off, reading/writing data, or controlling the head stepper motor phases. But due to the way the circuit was laid out on the disk controller card, they also have some unexpected behaviors. Many copy protection schemes relied on these undocumented side effects.</p>
<p>As referenced in the previous section, when you access $C088,X it begins the timer to turn off the drive motor. But, it also returns the value of the data latch! Why would it do that?!? It does this for one simple reason, the low bit of the address line (A0) is connected through a NOT gate to the Output Enable line of the data latch. Therefore every soft switch on an even address should actually return the value of the data latch.</p>
<p>Another nuance that needs to be implemented is that reading $C08D,X will reset the sequencer and clear the contents of the data latch. This is used to great effect in the E7 protection scheme to resynchronize the nibble stream to make timing bits become valid data bits.</p>
<hr />
<h2>WOZ File Format Specification</h2>
<p>A WOZ file uses a chunk-based file binary format that provides future-proof expandability in a way that is safe for older software which may not recognize newer data chunks.</p>
<p><b>All data is stored little-endian.</b></p>
<p>WOZ files begin with the following 12-byte header in order to identify the file type as well as detect any corruption that may have occurred. The easiest way to detect that a file is indeed a WOZ file is to check the first 8 bytes of the file for the signature. The remaining 4 bytes are a CRC of all remaining data in the file. This is only provided to allow you to ensure file integrity and is not necessary to process the file. If the CRC is 0x00000000, then no CRC has been calculated for the file and should be ignored. The exact CRC routine used is shown in Appendix A, and you should be passing in 0x00000000 as the initial crc value.</p>
<table class="aligncenter" style="width: 95%;" border="2">
<thead>
<tr style="background-color: #bbb;">
<th style="width: 8%;">Byte</th>
<th style="width: 17%;">Value</th>
<th style="width: 60%;">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td style="background-color: #ddd;">0</td>
<td><span style="color: #000000; font-family: 'Courier New'; font-size: medium;">57 4F 5A 32</span></td>
<td><span style="color: #000000; font-family: Helvetica; font-size: small;">The ASCII string âWOZ2â. </span><span style="color: #000000; font-family: 'Courier New'; font-size: medium;">0x325A4F57</span></td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;">4</td>
<td><span style="color: #000000; font-family: 'Courier New'; font-size: medium;">FF</span></td>
<td><span style="color: #000000; font-family: Helvetica; font-size: small;">Make sure that high bits are valid (no 7-bit data transmission)</span></td>
</tr>
<tr>
<td style="background-color: #ddd;">5</td>
<td><span style="color: #000000; font-family: 'Courier New'; font-size: medium;">0A 0D 0A</span></td>
<td><span style="color: #000000; font-family: Helvetica; font-size: small;">LF CR LF &#8211; File translators will often try to convert these.</span></td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;">8</td>
<td><span style="color: #000000; font-family: 'Courier New'; font-size: medium;">xx xx xx xx</span></td>
<td><span style="color: #000000; font-family: Helvetica; font-size: small;">CRC32 of all remaining data in the file. The method used to generate the CRC is described in Appendix A.</span></td>
</tr>
</tbody>
</table>
<p>After the header comes a sequence of chunks which each contain information about the disk image. Using chunks allows for the WOZ disk format to provide forward compatibility as chunks can be added to the specification and will just be safely ignored by applications that do not care (or know) about the information. For lower-performance emulation platforms, the primary data chunks are all located in fixed positions so that direct access to data is possible using just offsets from the start of the file.</p>
<p>All chunks have the following structure:</p>
<table class="aligncenter" style="width: 95%;" border="2">
<thead>
<tr style="background-color: #bbb;">
<th style="width: 10%;">Offset</th>
<th style="width: 10%;">Size</th>
<th style="width: 20%;">Name</th>
<th style="width: 55%;">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="background-color: #ddd;"><b>+0</b></td>
<td>4 bytes</td>
<td>Chunk ID</td>
<td>4 ASCII characters that make up the ID of the chunk</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;"><b>+4</b></td>
<td>uint32</td>
<td>Chunk Size</td>
<td>The size of the chunk data in bytes.</td>
</tr>
<tr>
<td style="background-color: #ddd;"><b>+8</b></td>
<td>â¦</td>
<td>Chunk Data</td>
<td>The chunk data.</td>
</tr>
</tbody>
</table>
<p>To process the file, you start at the first Chunk ID which will be located at byte 12 of the file, immediately following the header. You read the Chunk ID and the Chunk Size following it. If you want to process this chunk, then your file pointer will be at the start of the data. If you donât care about this chunk, then skip the number of bytes as Chunk Size indicates and you will now be at the next Chunk ID.</p>
<pre>while(data_stream.availableToRead() &gt; 8) {
	uint32_t chunk_id = data_stream.readU32();
	uint32_t chunk_size = data_stream.readU32();
	switch(chunk_id) {
	case INFO_CHUNK_ID:
		// read the INFO chunk
		break;
	case TMAP_CHUNK_ID:
		// read the TMAP chunk
		break;
	case TRKS_CHUNK_ID:
		// read the TRKS chunk
		break;
	case META_CHUNK_ID:
		// read the META chunk
		break;
	default:
		// no idea what this chunk is, so skip it
		data_stream.skip(chunk_size);
	}
}
</pre>
<hr />
<h3>INFO Chunk</h3>
<p>The first chunk in an Applesauce file is always an âINFOâ chunk. This contains some fundamental information about the contained image. The data of the âINFOâ chunk begins at byte 20 of the file and is 60 bytes long (pad chunk with zeros to full length).</p>
<table class="aligncenter" style="width: 95%;" border="2">
<thead>
<tr style="background-color: #bbb;">
<th style="width: 10%;">Byte</th>
<th style="width: 10%;">Offset</th>
<th style="width: 10%;">Type</th>
<th style="width: 10%;">Vers</th>
<th style="width: 20%;">Name</th>
<th style="width: 35%;">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="background-color: #ddd;" valign="top"><b>12</b></td>
<td style="background-color: #ddd;" valign="top"></td>
<td valign="top">uint32</td>
<td valign="top"></td>
<td valign="top">âINFOâ Chunk ID</td>
<td valign="top">0x4F464E49</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>16</b></td>
<td style="background-color: #ddd;" valign="top"></td>
<td valign="top">uint32</td>
<td valign="top"></td>
<td valign="top">Chunk Size</td>
<td valign="top">Size is always 60.</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>20</b></td>
<td style="background-color: #ddd;" valign="top"><b>+0</b></td>
<td valign="top">uint8</td>
<td valign="top">1</td>
<td valign="top">INFO Version</td>
<td valign="top">Version number of the INFO chunk.<br />
Current version is 2.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>21</b></td>
<td style="background-color: #ddd;" valign="top"><b>+1</b></td>
<td valign="top">uint8</td>
<td valign="top">1</td>
<td valign="top">Disk Type</td>
<td valign="top">1 = 5.25, 2 = 3.5</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>22</b></td>
<td style="background-color: #ddd;" valign="top"><b>+2</b></td>
<td valign="top">uint8</td>
<td valign="top">1</td>
<td valign="top">Write Protected</td>
<td valign="top">1 = Floppy is write protected</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>23</b></td>
<td style="background-color: #ddd;" valign="top"><b>+3</b></td>
<td valign="top">uint8</td>
<td valign="top">1</td>
<td valign="top">Synchronized</td>
<td valign="top">1 = Cross track sync was used during imaging</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>24</b></td>
<td style="background-color: #ddd;" valign="top"><b>+4</b></td>
<td valign="top">uint8</td>
<td valign="top">1</td>
<td valign="top">Cleaned</td>
<td valign="top">1 = MC3470 fake bits have been removed</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>25</b></td>
<td style="background-color: #ddd;" valign="top"><b>+5</b></td>
<td valign="top">UTF-8<br />
32 bytes</td>
<td valign="top">1</td>
<td valign="top">Creator</td>
<td valign="top">Name of software that created the WOZ file. String in UTF-8. No BOM. Padded to 32 bytes using space character (0x20).<br />
ex: âApplesauce v1.0 <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  </span>â</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>57</b></td>
<td style="background-color: #ddd;" valign="top"><b>+37</b></td>
<td valign="top">uint8</td>
<td valign="top">2</td>
<td valign="top">Disk Sides</td>
<td valign="top">The number of disk sides contained within this image. A 5.25 disk will always be 1. A 3.5 disk can be 1 or 2.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>58</b></td>
<td style="background-color: #ddd;" valign="top"><b>+38</b></td>
<td valign="top">uint8</td>
<td valign="top">2</td>
<td valign="top">Boot Sector Format</td>
<td valign="top">The type of boot sector found on this disk. This is only for 5.25 disks. 3.5 disks should just set this to 0.<br />
0 = Unknown<br />
1 = Contains boot sector for 16-sector<br />
2 =Â Contains boot sector for 13-sector<br />
3 = Contains boot sectors for both</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>59</b></td>
<td style="background-color: #ddd;" valign="top"><b>+39</b></td>
<td valign="top">uint8</td>
<td valign="top">2</td>
<td valign="top">Optimal Bit Timing</td>
<td valign="top">The ideal rate that bits should be delivered to the disk controller card. This value is in 125 nanosecond increments, so 8 is equal to 1 microsecond. And a standard bit rate for a 5.25 disk would be 32 (4Âµs).</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>60</b></td>
<td style="background-color: #ddd;" valign="top"><b>+40</b></td>
<td valign="top">uint16</td>
<td valign="top">2</td>
<td valign="top">Compatible Hardware</td>
<td valign="top">Bit field with a 1 indicating known compatibility. Multiple compatibility flags are possible. A 0 value represents that the compatible hardware list is unknown.<br />
0x0001 = Apple ][<br />
0x0002Â = Apple ][ Plus<br />
0x0004Â =Â Apple //e (unenhanced)<br />
0x0008Â = Apple //c<br />
0x0010Â = Apple //e Enhanced<br />
0x0020 = Apple IIgs<br />
0x0040Â = Apple //c Plus<br />
0x0080Â = Apple ///<br />
0x0100Â = Apple /// Plus</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>62</b></td>
<td style="background-color: #ddd;" valign="top"><b>+42</b></td>
<td valign="top">uint16</td>
<td valign="top">2</td>
<td valign="top">Required RAM</td>
<td valign="top">Minimum RAM size needed for this software. This value is in K (1024 bytes). If the minimum size is unknown, this value should be set to 0. So, a requirement of 64K would be indicated by the value 64 here.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>64</b></td>
<td style="background-color: #ddd;" valign="top"><b>+44</b></td>
<td valign="top">uint16</td>
<td valign="top">2</td>
<td valign="top">Largest Track</td>
<td valign="top">The number of blocks (512 bytes) used by the largest track. Can be used to allocate a buffer with a size safe for all tracks.</td>
</tr>
</tbody>
</table>
<p>The chunk is versioned to allow for adding additional info in the future. The âVersâ column in the table above indicates at which version the data field became available. When reading data from the chunk, make sure that value you are looking for actually exists within the version of the chunk you are reading.</p>
<hr />
<h3>TMAP Chunk</h3>
<p>The âTMAPâ chunk contains a track map. This allows you to map physical drive tracks with the track data contained within the image file âTRKSâ chunk. This system is used because, on a 5.25 drive, the physical drive head is larger than the width of the written track and so the track is also visible from neighboring quarter tracks. For example, the data of track 1.00 is actually visible while reading from track 0.75 or 1.25. Instead of storing copies of track data for every possible quarter track, we use the map to point multiple quarter tracks to a single track image.</p>
<table class="aligncenter" style="width: 95%;" border="2">
<tbody>
<tr>
<td valign="top"><b>Track</b></td>
<td valign="top">0.00</td>
<td valign="top">0.25</td>
<td valign="top">0.50</td>
<td valign="top">0.75</td>
<td valign="top">1.00</td>
<td valign="top">1.25</td>
<td valign="top">1.50</td>
<td valign="top">1.75</td>
<td valign="top">2.00</td>
<td valign="top">2.25</td>
<td valign="top">2.50</td>
<td valign="top">2.75</td>
<td valign="top">3.00</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top"><b>Maps</b></td>
<td valign="top">00</td>
<td valign="top">00</td>
<td valign="top">FF</td>
<td valign="top">01</td>
<td valign="top">01</td>
<td valign="top">01</td>
<td valign="top">FF</td>
<td valign="top">02</td>
<td valign="top">02</td>
<td valign="top">02</td>
<td valign="top">FF</td>
<td valign="top">03</td>
<td valign="top">03</td>
</tr>
</tbody>
</table>
<p>The data of the âTMAPâ chunk begins at byte 88 of the file and is 160 bytes long.</p>
<p>Each map entry contains an index number for the track data contained within the âTRKSâ chunk. If the map entry is 0, then the correct track data to be using is the first entry in the âTRKSâ chunk. Any blank tracks are given a value of 255 (0xFF) in the map and the emulator should be outputting random bits in this case.</p>
<p>The mapping changes slightly between 5.25 and 3.5 disks. This is the format for the table for the layout of a 5.25 disk. The table only shows to track 35, but can also accommodate 40 track disks. All unused map entries should have a 255 (0xFF) value.</p>
<table class="aligncenter" style="width: 95%;" border="2">
<thead>
<tr style="background-color: #bbb;">
<th style="width: 10%;">Byte</th>
<th style="width: 10%;">Offset</th>
<th style="width: 10%;">Type</th>
<th style="width: 23%;">Name</th>
<th style="width: 42%;">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="background-color: #ddd;" valign="top"><b>80</b></td>
<td style="background-color: #ddd;" valign="top"></td>
<td valign="top">uint32</td>
<td valign="top">âTMAPâ Chunk ID</td>
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">0x50414D54</span></td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>84</b></td>
<td style="background-color: #ddd;" valign="top"></td>
<td valign="top">uint32</td>
<td valign="top">Chunk Size</td>
<td valign="top">Size is always 160.</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>88</b></td>
<td style="background-color: #ddd;" valign="top"><b>+0</b></td>
<td valign="top">uint8</td>
<td valign="top">Track 0.00</td>
<td valign="top">Index of TRKS entry to use for Track 0.00.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>89</b></td>
<td style="background-color: #ddd;" valign="top"><b>+1</b></td>
<td valign="top">uint8</td>
<td valign="top">Track 0.25</td>
<td valign="top"></td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>90</b></td>
<td style="background-color: #ddd;" valign="top"><b>+2</b></td>
<td valign="top">uint8</td>
<td valign="top">Track 0.50</td>
<td valign="top"></td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>91</b></td>
<td style="background-color: #ddd;" valign="top"><b>+3</b></td>
<td valign="top">uint8</td>
<td valign="top">Track 0.75</td>
<td valign="top"></td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>92</b></td>
<td style="background-color: #ddd;" valign="top"><b>+4</b></td>
<td valign="top">uint8</td>
<td valign="top">Track 1.00</td>
<td valign="top"></td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>â¦</b></td>
<td style="background-color: #ddd;" valign="top"><b>â¦</b></td>
<td valign="top"></td>
<td valign="top">â¦</td>
<td valign="top"></td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>228</b></td>
<td style="background-color: #ddd;" valign="top"><b>+140</b></td>
<td valign="top">uint8</td>
<td valign="top">Track 35.00</td>
<td valign="top"></td>
</tr>
</tbody>
</table>
<p>This is the mapping for 3.5 disks:</p>
<table class="aligncenter" style="width: 95%;" border="2">
<thead>
<tr style="background-color: #bbb;">
<th style="width: 10%;">Byte</th>
<th style="width: 10%;">Offset</th>
<th style="width: 10%;">Type</th>
<th style="width: 23%;">Name</th>
<th style="width: 42%;">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="background-color: #ddd;" valign="top"><b>80</b></td>
<td style="background-color: #ddd;" valign="top"></td>
<td valign="top">uint32</td>
<td valign="top">âTMAPâ Chunk ID</td>
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">0x50414D54</span></td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>84</b></td>
<td style="background-color: #ddd;" valign="top"></td>
<td valign="top">uint32</td>
<td valign="top">Chunk Size</td>
<td valign="top">Size is always 160.</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>88</b></td>
<td style="background-color: #ddd;" valign="top"><b>+0</b></td>
<td valign="top">uint8</td>
<td valign="top">Track 0,Â Side 0</td>
<td valign="top">Index of TRKS entry to use for Track 0, Side 0.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>89</b></td>
<td style="background-color: #ddd;" valign="top"><b>+1</b></td>
<td valign="top">uint8</td>
<td valign="top">Track 0,Â Side 1</td>
<td valign="top"></td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>90</b></td>
<td style="background-color: #ddd;" valign="top"><b>+2</b></td>
<td valign="top">uint8</td>
<td valign="top">Track 1,Â Side 0</td>
<td valign="top"></td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>&#8230;</b></td>
<td style="background-color: #ddd;" valign="top"><b>&#8230;</b></td>
<td valign="top"></td>
<td valign="top">â¦</td>
<td valign="top"></td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>246</b></td>
<td style="background-color: #ddd;" valign="top"><b>+158</b></td>
<td valign="top">uint8</td>
<td valign="top">Track 79, Side 0</td>
<td valign="top"></td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>247</b></td>
<td style="background-color: #ddd;" valign="top"><b>+159</b></td>
<td valign="top">uint8</td>
<td valign="top">Track 79, Side 1</td>
<td valign="top"></td>
</tr>
</tbody>
</table>
<hr />
<h3>TRKS Chunk</h3>
<p>The âTRKSâ chunk contains the data for all of the unique tracks. The data of the âTRKSâ chunk begins at byte 256. For more efficient track data copying from SD cards and other block devices, all track data is stored in 512-byte blocks and the blocks are 512 byte aligned relative to the start of the WOZ file. The start of the TRKS chunk has an array of TRK structures to locate all of the actual bit data within the file. The actual bit data begins at byte 1536 (block 3) of the WOZ file. While every track can be a different size, this is rarely the case. Just about all 5.25 floppy disk tracks will tend to each be 13 blocks long. The track sizes for a 3.5 floppy disk will be different for each speed zone. If needed, the âINFOâ chunk contains a Largest Track value that you can use to safely allocate a storage buffer for any tracks in this WOZ file.</p>
<table class="aligncenter" style="width: 95%;" border="2">
<thead>
<tr style="background-color: #bbb;">
<th style="width: 10%;">Byte</th>
<th style="width: 10%;">Offset</th>
<th style="width: 10%;">Type</th>
<th style="width: 23%;">Name</th>
<th style="width: 42%;">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="background-color: #ddd;" valign="top"><b>248</b></td>
<td style="background-color: #ddd;" valign="top"></td>
<td valign="top">uint32</td>
<td valign="top">âTRKSâ Chunk ID</td>
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">0x534B5254</span></td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>252</b></td>
<td style="background-color: #ddd;" valign="top"></td>
<td valign="top">uint32</td>
<td valign="top">Chunk Size</td>
<td valign="top"></td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>256</b></td>
<td style="background-color: #ddd;" valign="top"><b>+0</b></td>
<td valign="top">TRK</td>
<td valign="top">Track 00</td>
<td valign="top">First track in track array. TMAP value of 0.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>264</b></td>
<td style="background-color: #ddd;" valign="top"><b>+8</b></td>
<td valign="top">TRK</td>
<td valign="top">Track 01</td>
<td valign="top">Second track in track array. TMAP value of 1.</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>272</b></td>
<td style="background-color: #ddd;" valign="top"><b>+16</b></td>
<td valign="top">TRK</td>
<td valign="top">Track 02</td>
<td valign="top">Third track in track array. TMAP value of 2.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>&#8230;</b></td>
<td style="background-color: #ddd;" valign="top"><b>&#8230;</b></td>
<td valign="top"></td>
<td valign="top">&#8230;</td>
<td valign="top"></td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>1528</b></td>
<td style="background-color: #ddd;" valign="top"><b>+1272</b></td>
<td valign="top">TRK</td>
<td valign="top">Track 159</td>
<td valign="top">Last track in track array. TMAP value of 159.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>1536</b></td>
<td style="background-color: #ddd;" valign="top"><b>+1280</b></td>
<td valign="top">BITS</td>
<td valign="top">Beginning of Track Data Blocks</td>
<td valign="top">Start of the actual track bits.</td>
</tr>
</tbody>
</table>
<p>The structure of the TRK type in the previous table is as follows:</p>
<table class="aligncenter" style="width: 95%;" border="2">
<thead>
<tr style="background-color: #bbb;">
<th style="width: 10%;">Byte</th>
<th style="width: 10%;">Offset</th>
<th style="width: 10%;">Type</th>
<th style="width: 23%;">Name</th>
<th style="width: 42%;">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="background-color: #ddd;" valign="top"><b>&#8211;</b></td>
<td style="background-color: #ddd;" valign="top"><strong>+0</strong></td>
<td valign="top">uint16</td>
<td valign="top">Starting Block</td>
<td valign="top">First block of BITS data. This value is relative to the start of the file, so the first possible starting block is 3. Multiply this value by 512 (x &lt;&lt; 9) to get the starting byte of the BITS data.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>&#8211;</b></td>
<td style="background-color: #ddd;" valign="top"><strong>+2</strong></td>
<td valign="top">uint16</td>
<td valign="top">Block Count</td>
<td valign="top">Number of blocks for this BITS data.</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>&#8211;</b></td>
<td style="background-color: #ddd;" valign="top"><strong>+4</strong></td>
<td valign="top">uint32</td>
<td valign="top">Bit Count</td>
<td valign="top">The number of bits in the bitstream.</td>
</tr>
</tbody>
</table>
<p>The TRKS chunk always contains 160 TRK entires, but most disks will not use them all. All unused TRK structures should be filled out with zeros for all values.</p>
<p>The bitstream data is the series of bits recorded from the floppy drive and normalized to 4Âµs intervals for 5.25 disks and 2Âµs for 3.5 disks. The bits are packed into bytes, but the bytes will not necessarily be representative of nibble values as timing bits are also represented within the bitstream. When processing the bitstream, the order of bits within each byte is high to low, meaning the high bit goes first and the low bit is last. Since this bitstream is the flow of data directly from the floppy drive, it will need to pass through a Logic State Sequencer as found on the Disk II Interface Card, Apple 5.25 Drive Controller Card or IWM chip to create nibbles. But, due to the fact that the bitstream timing has already been normalized, you can use a very lightweight implementation of one. The Logic State Sequencer performs the function of converting the bitstream to a nibble stream as well as enforcing the proper nibble timing that many copy protection schemes will check.</p>
<p>If you are creating a floppy drive emulator for use with a real Apple II, then you will simply be stepping to the next bit in the bitstream at the rate specified by the Optimal Bit Timing in the INFO chunk. If the bit has a 1 value, then you send a 1Âµs pulse on the RDDATA line. For a 3.5 drive, the pulse width would be 0.5Âµs.</p>
<p>If the Cleaned value of the âINFOâ chunk is 1, then any fake bits generated by the MC3470 during the imaging process will have been removed and replaced with 0 bit values (see the Implementation Details section for proper handling of these).</p>
<hr />
<h3>WRIT Chunk (optional)</h3>
<p>The âWRITâ chunk contains the information necessary to be able to write the WOZ file to a physical floppy.</p>
<table class="aligncenter" style="width: 95%;" border="2">
<thead>
<tr style="background-color: #bbb;">
<th style="width: 10%;">Byte</th>
<th style="width: 10%;">Offset</th>
<th style="width: 10%;">Type</th>
<th style="width: 23%;">Name</th>
<th style="width: 42%;">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="background-color: #ddd;" valign="top"><b>&#8211;</b></td>
<td style="background-color: #ddd;" valign="top"></td>
<td valign="top">uint32</td>
<td valign="top">âWRITâ Chunk ID</td>
<td valign="top">0x54495257</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>&#8211;</b></td>
<td style="background-color: #ddd;" valign="top"></td>
<td valign="top">uint32</td>
<td valign="top">Chunk Size</td>
<td valign="top"></td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>&#8211;</b></td>
<td style="background-color: #ddd;" valign="top">+0</td>
<td valign="top">WTRK</td>
<td valign="top">Array of Track Writes</td>
<td valign="top"></td>
</tr>
</tbody>
</table>
<p>The WTRK structure provides all of the information for writing a single track to disk. Within each write there is the ability to Â insert multiple write commands. Each write command specifies which bits should be written to which area of the disk. For many simple disk layouts, there will just be a single write command for the entire track. But more complex writes, like if you needed to have data interleaved on neighboring half or even quarter tracks, can be done using multiple write command. The primary difference between using a single write command vs multiple is that the drive head is in write mode for the entire duration of a write command. Between write commands, the drive head is in read mode. This allows you to ensure that data on neighboring tracks is not overwritten.</p>
<table class="aligncenter" style="width: 95%;" border="2">
<thead>
<tr style="background-color: #bbb;">
<th style="width: 10%;">Offset</th>
<th style="width: 18%;">Size</th>
<th style="width: 25%;">Name</th>
<th style="width: 42%;">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="background-color: #ddd;" valign="top"><b>+0</b></td>
<td valign="top">uint8</td>
<td valign="top">Track Number</td>
<td valign="top">The track number at which to write this data. For 5.25 disks, this value is in half-phases or quarter tracks (0 = 0.00, 4 = 1.00, 5 = 1.25). For 3.5 disks, this value indicates track number as well as side. The formula ((track &lt;&lt; 1) + side) can be used (0 = Track 0, Side 0, 1 = Track 0, Side 1, 2 = Track 1, Side 0).</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>+1</b></td>
<td valign="top">uint8</td>
<td valign="top">Command Count</td>
<td valign="top">The number of commands in the write array.</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>+2</b></td>
<td valign="top">uint8</td>
<td valign="top">Additional Write Functions Bit Field</td>
<td valign="top">Bit field with a 1 indicating to perform the action:<br />
0x01 = Wipe the track before writing.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>+3</b></td>
<td valign="top">uint8</td>
<td valign="top">&#8211;</td>
<td valign="top">Reserved and must be zero.</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>+4</b></td>
<td valign="top">uint32</td>
<td valign="top">BITS checksum</td>
<td valign="top">Checksum of the entire used BITS data of this TRK. The proper data length can be calculated by (TRK.bitCount + 7) / 8. Used to determine if the BITS has changed since the WRIT chunk was written.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>+8</b></td>
<td valign="top">WCMD</td>
<td valign="top">Array of Write Commands</td>
<td valign="top"></td>
</tr>
</tbody>
</table>
<p>The structure of the WCMD type is as follows:</p>
<table class="aligncenter" style="width: 95%;" border="2">
<thead>
<tr style="background-color: #bbb;">
<th style="width: 10%;">Offset</th>
<th style="width: 18%;">Size</th>
<th style="width: 25%;">Name</th>
<th style="width: 42%;">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="background-color: #ddd;" valign="top"><b>+0</b></td>
<td valign="top">uint32</td>
<td valign="top">Index of starting bit</td>
<td valign="top">The index of the first bit of this write.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>+4</b></td>
<td valign="top">uint32</td>
<td valign="top">Bit Count</td>
<td valign="top">The number of bits to write.</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>+8</b></td>
<td valign="top">uint8</td>
<td valign="top">Leader Nibble</td>
<td valign="top">If this write requires leader nibbles, then this is the value for it. Typical value for this is 0xFF. If no leader is needed, then set value to 0x00.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>+9</b></td>
<td valign="top">uint8</td>
<td valign="top">Leader Nibble Bit Count</td>
<td valign="top">The number of bits that leader nibbles have. Typical value for DOS 3.3 and ProDOS would be 10.</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>+10</b></td>
<td valign="top">uint8</td>
<td valign="top">Leader Count</td>
<td valign="top">The number of Leader Nibbles that should be written before the bit data.</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>+11</b></td>
<td valign="top">uint8</td>
<td valign="top">&#8211;</td>
<td valign="top">Reserved and currently used to pad each WCMD to 4 byte boundaries. Must be zero.</td>
</tr>
</tbody>
</table>
<p>The Leader Nibble information in the WCMD structure is used to ensure a clean gap 1, it contains a nibble value and bit count for the nibbles that should be written before the data bits. For a normal DOS 3.3 or ProDOS disk, the leader would be 128 FF/10 nibbles.</p>
<hr />
<h3>META Chunk (optional)</h3>
<p>The âMETAâ chunk contains metadata for the disk image and its existence is optional in the WOZ file. The metadata is stored as a tab-delimited UTF-8 list of keys and values. Columns are by separated by a tab character (â\tâ 0x09). All rows end with a linefeed character (â\nâ 0x0A)</p>
<table class="aligncenter" style="width: 95%;" border="2">
<thead>
<tr style="background-color: #bbb;">
<th style="width: 10%;">Byte</th>
<th style="width: 10%;">Offset</th>
<th style="width: 10%;">Type</th>
<th style="width: 23%;">Name</th>
<th style="width: 42%;">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="background-color: #ddd;" valign="top"><b>&#8211;</b></td>
<td style="background-color: #ddd;" valign="top"></td>
<td valign="top">uint32</td>
<td valign="top">âMETAâ Chunk ID</td>
<td valign="top">0x4154454D</td>
</tr>
<tr style="background-color: #eee;">
<td style="background-color: #ddd;" valign="top"><b>&#8211;</b></td>
<td style="background-color: #ddd;" valign="top"></td>
<td valign="top">uint32</td>
<td valign="top">Chunk Size</td>
<td valign="top">Length of the metadata string in bytes.</td>
</tr>
<tr>
<td style="background-color: #ddd;" valign="top"><b>&#8211;</b></td>
<td style="background-color: #ddd;" valign="top"><b>+0</b></td>
<td valign="top">String</td>
<td valign="top">Metadata</td>
<td valign="top">Metadata string in UTF-8. No BOM.</td>
</tr>
</tbody>
</table>
<p>This is the list of standard metadata keys. Multiple values are pipe-separated.</p>
<table class="aligncenter" style="width: 96%;" border="2">
<thead>
<tr style="background-color: #bbb;">
<th style="width: 32%;">Key</th>
<th style="width: 32%;">Purpose</th>
<th style="width: 32%;">Example Value</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">title</span></td>
<td valign="top">Name/Title of the product.</td>
<td valign="top">Prince of Persia</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">subtitle</span></td>
<td valign="top">Subtitle of the product.</td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">publisher</span></td>
<td valign="top">Publisher of the software.</td>
<td valign="top">BrÃ¸derbund Software, Inc.</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">developer</span></td>
<td valign="top">Developer of the software. Pipe-delimited list if needed.</td>
<td valign="top">Jordan Mechner</td>
</tr>
<tr>
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">copyright</span></td>
<td valign="top">Copyright date. Free form text allowed.</td>
<td valign="top">1989<br />
1987 Muse Software</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">version</span></td>
<td valign="top">Version number of the software. Free form text allowed.</td>
<td valign="top">1.0<br />
19870115P</td>
</tr>
<tr>
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">language</span></td>
<td valign="top">Language (see table A)</td>
<td valign="top">English</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">requires_ram</span></td>
<td valign="top">RAM requirements (see table B)</td>
<td valign="top">64K</td>
</tr>
<tr>
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">requires_machine</span></td>
<td valign="top">Which computers does this run on? Pipe-delimited list. (see table C)</td>
<td valign="top">2+|2e|2c|2gs</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">notes</span></td>
<td valign="top">Additional notes.</td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">side</span></td>
<td valign="top">Physical disk side formatted as:<br />
âDisk #, Side [A|B]â</td>
<td valign="top">Disk 1, Side A</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">side_name</span></td>
<td valign="top">Name of the disk side. If the disk side is named on the label like Player, Town, Dungeon, etc then it goes here.</td>
<td valign="top">Front</td>
</tr>
<tr>
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">contributor</span></td>
<td valign="top">Name of the person who imaged the disk.</td>
<td valign="top">Mr. Pirate</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top"><span style="color: #000000; font-family: Courier New; font-size: medium;">image_date</span></td>
<td valign="top">RFC3339 date of the imaging.</td>
<td valign="top">2018-01-07T05:00:02.511Z</td>
</tr>
</tbody>
</table>
<p>If a standard key has no value, then the value will be an empty string. Key names are case-sensitive. Values cannot contain pipe, linefeed or tab characters. It would also be a good idea to keep all values as ASCII-friendly as possible to ensure compatibility with the widest range of devices that will consume these files. No duplicate keys are allowed and key order does not matter. Standard keys that have values laid out in the tables below cannot have values other that those shown below. Implementors are free to add additional keys to the metadata as long as they follow the same rules laid out here.</p>
<h5 style="text-align: center;">TABLE A- LANGUAGES</h5>
<table class="aligncenter" style="width: 80%;" border="2">
<tbody>
<tr>
<td style="width: 20%;">English</td>
<td style="width: 20%;">Spanish</td>
<td style="width: 20%;">French</td>
<td style="width: 20%;">German</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top">Chinese</td>
<td valign="top">Japanese</td>
<td valign="top">Italian</td>
<td valign="top">Dutch</td>
</tr>
<tr>
<td valign="top">Portuguese</td>
<td valign="top">Danish</td>
<td valign="top">Finnish</td>
<td valign="top">Norwegian</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top">Swedish</td>
<td valign="top">Russian</td>
<td valign="top">Polish</td>
<td valign="top">Turkish</td>
</tr>
<tr>
<td valign="top">Arabic</td>
<td valign="top">Thai</td>
<td valign="top">Czech</td>
<td valign="top">Hungarian</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top">Catalan</td>
<td valign="top">Croatian</td>
<td valign="top">Greek</td>
<td valign="top">Hebrew</td>
</tr>
<tr>
<td valign="top">Romanian</td>
<td valign="top">Slovak</td>
<td valign="top">Ukrainian</td>
<td valign="top">Indonesian</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top">Malay</td>
<td valign="top">Vietnamese</td>
<td valign="top">Other</td>
<td valign="top"></td>
</tr>
</tbody>
</table>
<h5 style="text-align: center;"><b>TABLE B &#8211; REQUIRES_RAM</b></h5>
<table class="aligncenter" style="width: 80%;" border="2">
<tbody>
<tr>
<td style="width: 20%;">16K</td>
<td style="width: 20%;">24K</td>
<td style="width: 20%;">32K</td>
<td style="width: 20%;">48K</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top">64K</td>
<td valign="top">128K</td>
<td valign="top">256K</td>
<td valign="top">512K</td>
</tr>
<tr>
<td valign="top">768K</td>
<td valign="top">1M</td>
<td valign="top">1.25M</td>
<td valign="top">1.5M+</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top">Unknown</td>
<td valign="top"></td>
<td valign="top"></td>
<td valign="top"></td>
</tr>
</tbody>
</table>
<h5 style="text-align: center;"><b>TABLE C &#8211; REQUIRES_MACHINE</b></h5>
<table class="aligncenter" style="width: 80%;" border="2">
<tbody>
<tr>
<td style="width: 20%;">2</td>
<td style="width: 20%;">2+</td>
<td style="width: 20%;">2e</td>
<td style="width: 20%;">2c</td>
</tr>
<tr style="background-color: #eee;">
<td valign="top">2e+</td>
<td valign="top">2gs</td>
<td valign="top">2c+</td>
<td valign="top">3</td>
</tr>
<tr>
<td valign="top">3+</td>
<td valign="top"></td>
<td valign="top"></td>
<td valign="top"></td>
</tr>
</tbody>
</table>
<hr />
<h2>Appendix A: CRC Routine</h2>
<p>The integrity of the WOZ files are protected by a standard 32-bit CRC. The routine that has been chosen for use originated with Gary S. Brown in 1986 and is implemented as follows:</p>
<pre>static uint32_t crc32_tab[] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
	0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
	0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
	0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
	0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
	0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
	0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
	0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
	0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
	0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
	0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
	0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
	0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
	0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
	0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
	0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
	0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
	0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
	0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
	0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
	0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
	0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

uint32_t crc32(uint32_t crc, const void *buf, size_t size)
{
	const uint8_t *p;
	p = buf;
	crc = crc ^ ~0U;
	while (size--)
	crc = crc32_tab[(crc ^ *p++) &amp; 0xFF] ^ (crc &gt;&gt; 8);
	return crc ^ ~0U;
}</pre>
	</div><!-- .entry-content -->

	
	
</article><!-- #post-350 -->


		</main><!-- #main -->
	</div><!-- #primary -->


		
	</div><!-- #content -->

	
	<footer id="colophon" class="site-footer" role="contentinfo">

		<div class="container"><div class="footer-widgets"><div class="footer-widget-1"></div><div class="footer-widget-2"></div><div class="footer-widget-3"></div></div>
		<div class="site-info">
			Powered by			<a href="https://tajam.id/miniva/">
				Miniva WordPress Theme			</a>
		</div><!-- .site-info -->

		</div>
	</footer><!-- #colophon -->
</div><!-- #page -->

<script type='text/javascript'>
/* <![CDATA[ */
var wpcf7 = {"apiSettings":{"root":"https:\/\/applesaucefdc.com\/wp-json\/contact-form-7\/v1","namespace":"contact-form-7\/v1"},"cached":"1"};
/* ]]> */
</script>
<script type='text/javascript' src='https://applesaucefdc.com/wp-content/plugins/contact-form-7/includes/js/scripts.js?ver=5.1.3'></script>
<script type='text/javascript' src='https://www.google.com/recaptcha/api.js?render=6LdqJoIUAAAAAD4UpwTR8d0-JRSuPmshQC5A2wi9&#038;ver=3.0'></script>
<script type='text/javascript' src='https://applesaucefdc.com/wp-content/themes/miniva/js/functions.js?ver=5.2.2'></script>
<script type='text/javascript' src='https://applesaucefdc.com/wp-includes/js/wp-embed.min.js?ver=5.2.2'></script>
<script type="text/javascript">
( function( grecaptcha, sitekey, actions ) {

	var wpcf7recaptcha = {

		execute: function( action ) {
			grecaptcha.execute(
				sitekey,
				{ action: action }
			).then( function( token ) {
				var forms = document.getElementsByTagName( 'form' );

				for ( var i = 0; i < forms.length; i++ ) {
					var fields = forms[ i ].getElementsByTagName( 'input' );

					for ( var j = 0; j < fields.length; j++ ) {
						var field = fields[ j ];

						if ( 'g-recaptcha-response' === field.getAttribute( 'name' ) ) {
							field.setAttribute( 'value', token );
							break;
						}
					}
				}
			} );
		},

		executeOnHomepage: function() {
			wpcf7recaptcha.execute( actions[ 'homepage' ] );
		},

		executeOnContactform: function() {
			wpcf7recaptcha.execute( actions[ 'contactform' ] );
		},

	};

	grecaptcha.ready(
		wpcf7recaptcha.executeOnHomepage
	);

	document.addEventListener( 'change',
		wpcf7recaptcha.executeOnContactform, false
	);

	document.addEventListener( 'wpcf7submit',
		wpcf7recaptcha.executeOnHomepage, false
	);

} )(
	grecaptcha,
	'6LdqJoIUAAAAAD4UpwTR8d0-JRSuPmshQC5A2wi9',
	{"homepage":"homepage","contactform":"contactform"}
);
</script>

</body>
</html>

<!-- Dynamic page generated in 0.238 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2019-08-06 08:39:41 -->

<!-- super cache -->